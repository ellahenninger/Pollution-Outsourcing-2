---
title: "Pollution Outsourcing and Democracy 2"
author: "Ella Henninger"
date: "2023-07-25"
output:
  word_document: default
  html_document: default
---

# Contents of the replication packet

This R-Markdown file replicates all analyses and figures included in the paper "What Makes Democracies Greener? The Role of Pollution Offshoring" by Tobias BÃ¶hmelt, Ella Henninger, and Thomas Bernauer.

## Data
 - **Main data**: Quality of Governance database (QoG), https://www.gu.se/en/quality-government/qog-data
 - **Economic data**: World Development Indicators (2023), https://databank.worldbank.org/source/world-development-indicators#
 - **Democracy data**: V-Dem (2023), https://www.v-dem.net/data/the-v-dem-dataset/


**The code is structured as follows**:

1. Set up

2. Preparatory steps
2.1 Load data
2.2 Create lagged and logged variables

3. Descriptives
3.1 Table summary statistics
3.2 Correlations

4. Analyses
4.1 Models Democracy and pollution outsourcing
4.2 Models Pollution outsourcing and environmental performance

5. Quantities of interest
5.1 Simulated interaction term and marginal effects
5.2 Expected values outsourcing & first difference: high/low democracy

6. Robustness checks
6.1 Replacing DV with ecological footprint data
6.2 Replacing DV with change in CO2
6.3 Replacing democracy variable with Freedom House and Polity V
6.4 Including additional controls: Political globaliz. & Environm. treaties
6.5 Restricting data to FDI inflow >= 0
6.6 Excluding lagged DV
6.7 Checking for autocorrelation and panel-corrected SEs
6.8 GGM dynamic panel estimator
6.9 Random effects model
6.10 Random subsamples

**As a note**: You may be asked to update some packages, please press "yes" to make sure the file runs smoothly.


# Set up

```{r setup, include=FALSE}

## clean environment
rm(list = ls())

# Define which packages needed for analyses
p_needed <-
  c("knitr",
    "dplyr", 
    "psych",
    "stargazer",
    "ggplot2",
    "viridis",
    "haven",
    "MASS",
    "modelsummary",
    "WDI",
    "plm",
    "lmtest",
    "ggmap",
    "maps",
    "tidyr",
    "devtools",
    "data.table",
    "sjPlot",
    "interplot",
    "fastDummies",
    "texreg")

# Check which packages are already installed on your computer
packages <- rownames(installed.packages())

# Check which packages are not installed
p_to_install <- p_needed[!(p_needed %in% packages)]

if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_needed, require, character.only = TRUE)


# Set an option for the final document that can be produced from the .Rmd file.
knitr::opts_chunk$set(echo = TRUE)

## For replicability: session information 
session_info <- print(sessionInfo())

```


# Preparatory steps

## Load data

```{r load data}

#-------------------------------------------------------------------------------
# Data
#-------------------------------------------------------------------------------
data <- read_dta("data/QoG/qog_std_ts_jan23_stata14.dta")

#-------------------------------------------------------------------------------
# Filter data
#-------------------------------------------------------------------------------
data <- data[which(data$year >= 1989),]
data <- data[which(data$year <= 2022),]

```

## Create lagged and logged variables 

```{r variable selection}

#-------------------------------------------------------------------------------
# Create logs
#-------------------------------------------------------------------------------
data$insourced_GHG <- data$cf_cc_pop_mean
data$log_wdi_co2 <- log(1 + data$wdi_co2)  ## plus 1 to avoid negative numbers

## outsourced CO2
data$log_cc_outs <- log(data$cf_cc_pop_mean_outs)

## pm2.5
data$log_pm25_pop <- log(data$populationweightedpm25ugm3)
data$log_pm25_geo <- log(data$geographicmeanpm25ugm3)

## carbon footprint of consumption
data$log_ef_carb <- log(data$ef_carb)

## population
data$log_pop <- log(data$wdi_pop)
data$log_pop_den <- log(data$wdi_popden)

## gdp
data$log_gdp_pc <- log(data$wdi_gdpcapcon2015)
data$log_gdp_pc_sq <- data$log_gdp_pc^2
data$log_gdp <- log(data$wdi_gdppppcon2017)


#-------------------------------------------------------------------------------
# Create environmental treaties variable
#-------------------------------------------------------------------------------
data <- data %>% 
  group_by(ccode) %>% 
  mutate(env_treaties = ifelse(any(!is.na(iea_sum_i)), zoo::na.locf(iea_sum_i), NA))

data$env_treaties <- data$env_treaties/100

#-------------------------------------------------------------------------------
# Transform Freedom House civil liberties variable
#-------------------------------------------------------------------------------
data$fh_cl <- 8 - data$fh_cl

#-------------------------------------------------------------------------------
# Create environmental treaties variable
#-------------------------------------------------------------------------------
data <- data %>% 
  group_by(ccode) %>% 
  mutate(env_treaties = ifelse(any(!is.na(iea_sum_i)), zoo::na.locf(iea_sum_i), NA))

data$env_treaties <- data$env_treaties/100

#-------------------------------------------------------------------------------
# Rescale political globalization variable (1-10)
#-------------------------------------------------------------------------------
data$dr_pg <- data$dr_pg/100

#-------------------------------------------------------------------------------
# Subset data to relevant variables
#-------------------------------------------------------------------------------
data_s <- dplyr::select(data, "cname", "ccode", "year", "ccodealp", 
                              "insourced_GHG", "cf_cc_pop_mean", "cf_cc_pop_mean_outs", "log_cc_outs",
                              "log_pm25_pop", "log_pm25_geo", "log_wdi_co2",
                              "populationweightedpm25ugm3", "geographicmeanpm25ugm3",
                              "ef_carb", "log_ef_carb",
                              "vdem_polyarchy", "log_gdp_pc", "log_gdp_pc_sq", "log_gdp",
                              "log_pop", "log_pop_den", "fh_cl", "fh_fog",
                              "cf_bw_pop_mean_outs", "cf_en_pop_mean_outs", "cf_lu_pop_mean_outs", "cf_mf_pop_mean_outs",
                              "dr_pg", "fh_status", "env_treaties",  "wdi_trade",
                              "p_polity2", "vdem_partip", "vdem_delibdem")

```


# Descriptives

## Table summary statistics

```{r descriptives}

#-------------------------------------------------------------------------------
# Table: Summary statistics
#-------------------------------------------------------------------------------
# data_descript <- data_s[which(!is.na(data_s$log_cc_outs) &
#                               data_s$log_ef_carb != -Inf),]
# 
# options("modelsummary_format_numeric_latex" = "plain")
# datasummary(formula = (`Pollution Outsourcing` = cf_cc_pop_mean_outs) + (`ln(Pollution Outsourcing)` = log_cc_outs) +
#                       (`PM2.5 (pop. weighted)` = populationweightedpm25ugm3) + (`ln(PM2.5) (pop. weighted)` = log_pm25_pop) +
#                       (`PM2.5 (geo. mean)` = geographicmeanpm25ugm3) +  (`ln(PM2.5) (geo. mean)` = log_pm25_geo) +
#                       (`ln(CO2)` = log_wdi_co2) +  (`ln(Environm. Footprint Consumpt.)` = log_ef_carb) +
#                       (`Democracy` = vdem_polyarchy) + (`ln(GDP)` = log_gdp) +
#                       (`ln(GDP per capita)` = log_gdp_pc) + (`ln(Populat. Size)`= log_pop) +
#                       (`Civil liberties (Freedom House)` = fh_cl) +
#                       (`Democracy (Polity V)` = p_polity2) + (`Political Globaliz.` = dr_pg) +
#                       (`Trade Openness` = wdi_trade) + (`Environm. Treaties` = env_treaties)
#               ~ N + Mean + SD + Min + Median + Max,
#             title = "Summary statistics",
#             data = data_descript,
#             output = "latex")
summary(data_s$log_cc_outs)
```

## Correlations

```{r correlations}

#-------------------------------------------------------------------------------
## Correlation heat map
#-------------------------------------------------------------------------------
data_cor <- data_descript[,c("log_cc_outs", "log_pm25_pop", "log_wdi_co2", "log_ef_carb",
                             "vdem_polyarchy", "log_gdp", "log_gdp_pc", "log_pop", 
                             "fh_cl", "p_polity2", "wdi_trade", "env_treaties", "dr_pg")]

data_cor <- na.omit(data_cor)

cormat <- round(cor(data_cor), 2)
melted_cormat <- melt(cormat)

ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  scale_fill_gradient2(midpoint= 0, 
                       low = viridis(3)[1], 
                       mid = "white",
                       high = viridis(3)[2], 
                       na.value = "grey50", space ="Lab") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  geom_tile()


#-------------------------------------------------------------------------------
## Correlation pm2.5 & outsourcing
#-------------------------------------------------------------------------------
cor(data_cor$log_pm25_pop, data_cor$log_cc_outs) ## -0.30
cor(data_cor$log_pm25_pop, data_cor$log_wdi_co2) ## -0.27
cor(data_cor$log_pm25_pop, data_cor$log_ef_carb) ## -0.35

```



# Analyses

## Model group 1: Democracy and Pollution Outsourcing

```{r models dem and poll outsourcing}

#-------------------------------------------------------------------------------
# Base model
#-------------------------------------------------------------------------------
m1_outsource <- lm(log_cc_outs ~ vdem_polyarchy + 
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

#-------------------------------------------------------------------------------
# Controls
#-------------------------------------------------------------------------------
m2_c <- lm(log_cc_outs ~ log_pop + log_gdp_pc + log_gdp_pc_sq +
                      as.factor(year) + as.factor(ccode),
                     data = data_s[which(!is.na(data_s$vdem_polyarchy)),])

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_outsource_c <- lm(log_cc_outs ~ vdem_polyarchy + log_pop + log_gdp_pc + log_gdp_pc_sq + 
                      as.factor(year) + as.factor(ccode),
                     data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls + restriction
#-------------------------------------------------------------------------------
m4_restricted_c <- lm(log_cc_outs ~ vdem_polyarchy + log_pop + log_gdp_pc + log_gdp_pc_sq +
                       as.factor(year) + as.factor(ccode),
                      data = data_s[which(!is.na(data_s$log_pm25_pop)),])


## Output
htmlreg(list(m1_outsource, m2_c, m3_outsource_c, m4_restricted_c),
       file = "texreg1.doc",
       stars = c(0.01, 0.05, 0.1),
       custom.header = list("Pollution Outsourcing" = 1:4),
       caption = "Democracy and Pollution Outsourcing",
       label = "tab:table1",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("vdem_polyarchy" = "Democracy",
                              "log_pop" = "Population",
                              "log_gdp_pc" = "GDP per capita",
                              "log_gdp_pc_sq" = "GDP per capita squ.", 
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\ding{51}", "\\ding{51}","\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}")))


#-------------------------------------------------------------------------------
# Coefficient plot 
#-------------------------------------------------------------------------------
pdf("plots/Coefficients_table1.pdf", width = 7.5)
par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))

modelplot(m3_outsource_c, 
          coef_map = c("log_gdp_pc_sq" = "GDP per capita squ.",
                       "log_gdp_pc" = "GDP per capita",
                       "log_pop" = "Population",
                       "vdem_polyarchy" = "Democracy"),
          color = viridis(1, alpha = 0.5), 
          size = 0.9,
          linewidth = 1.8) +
  labs(title="Regression Coefficients - Table 1, Model 3") +
  geom_vline(xintercept = 0)

dev.off()

```

## Model group 2: Environmental Performance and Pollution Outsourcing

```{r models env perform and poll outsourcing}

#-------------------------------------------------------------------------------
# Base model
#-------------------------------------------------------------------------------
m5_out_dem <- lm(log_pm25_pop ~ log_cc_outs + vdem_polyarchy + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m6_out_dem_int <- lm(log_pm25_pop ~ log_cc_outs + vdem_polyarchy + 
                      log_cc_outs*vdem_polyarchy +
                      as.factor(year) + as.factor(ccode),
                     data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m7_c <- lm(log_pm25_pop ~ log_pop + log_gdp_pc + log_gdp_pc_sq +
            as.factor(year) + as.factor(ccode),
           data = data_s[which(!is.na(data_s$log_pm25_pop) &
                               !is.na(data_s$log_cc_outs) &
                               !is.na(data_s$vdem_polyarchy)),])

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m8_out_dem_int_c <- lm(log_pm25_pop ~ log_cc_outs + vdem_polyarchy + 
                        log_cc_outs*vdem_polyarchy +
                        log_pop + log_gdp_pc + log_gdp_pc_sq +
                        as.factor(year) + as.factor(ccode),
                       data = data_s)

## Output
htmlreg(list(m5_out_dem, m6_out_dem_int, m7_c, m8_out_dem_int_c),
       stars = c(0.01, 0.05, 0.1),
       file = "texreg2.doc",
       custom.header = list("PM2.5 (pop. weighted)" = 1:4),
       caption = "Environmental Performance and Pollution Outsourcing",
       custom.model.names = c("Model 5", "Model 6", "Model 7", "Model 8"),
       label = "tab:table2",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("log_cc_outs" = "Pollution Outsourcing",
                              "vdem_polyarchy" = "Democracy",
                              "log_cc_outs:vdem_polyarchy" = "Democracy x Pollution Outsourcing",
                              "log_pop" = "Population",
                              "log_gdp_pc" = "GDP per capita",
                              "log_gdp_pc_sq" = "GDP per capita squ.",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\ding{51}", "\\ding{51}","\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}")))

#-------------------------------------------------------------------------------
# Coefficient plot 
#-------------------------------------------------------------------------------
pdf("plots/Coefficients_table2.pdf", width = 7.5)
par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))

modelplot(m8_out_dem_int_c, 
          coef_map = c("log_gdp_pc_sq" = "GDP per capita squ.",
                       "log_gdp_pc" = "GDP per capita",
                       "log_pop" = "Population",
                       "log_cc_outs:vdem_polyarchy" = "Democracy x Poll. Outsourc.",
                       "vdem_polyarchy" = "Democracy",
                       "log_cc_outs" = "Pollution Outsourcing"),
          color = viridis(1, alpha = 0.5), 
          size = 0.9,
          linewidth = 1.8) +
  labs(title="Regression Coefficients - Table 2, Model 8") +
  geom_vline(xintercept = 0)

dev.off()

```


# Quantities of interest

## Simulated interaction & marginal effects

```{r plots simulated interaction effect}

#-------------------------------------------------------------------------------
# Simulate interaction effect 
#-------------------------------------------------------------------------------
nsim <- 1000
beta_hat <- coef(m8_out_dem_int_c)
V_hat <- vcov(m8_out_dem_int_c)
S <- mvrnorm(nsim, beta_hat, V_hat)
quants_S <- apply(S, 2, quantile, probs = c(0.025, 0.5, 0.975))

## Plot interaction term
pdf("plots/sim_interact_outsource_dem.pdf")

plot(density(S[,"log_cc_outs:vdem_polyarchy"]),
     las = 1,
     lwd = 3,
     col = viridis(4)[1],
     bty = "n",
     cex = 1.1,
     cex.lab = 1.3,
     yaxt = "n",
     ylab = "Density",
     main = "Democracy x Pollution Outsourcing",
     xlab = "Simulated Interaction Effect")

abline(v = c(quants_S[c(1,3), "log_cc_outs:vdem_polyarchy"]), lty = 2, col = viridis(3)[2])
abline(v = c(quants_S[2,"log_cc_outs:vdem_polyarchy"]), lty = 1, lwd = 1.5, col = viridis(3)[2])
abline(v = 0, lty = 1, lwd = 1, col = "black")

legend("topleft",
       lty = c("solid", "dashed"),
       col = c(viridis(3)[2], viridis(3)[2]),
       legend = c("Mean", "95% CIs"),
       bty = "n")

dev.off()


#-------------------------------------------------------------------------------
# Simulate marginal effects 
#-------------------------------------------------------------------------------

# library(marginaleffects)
# library(ggExtra)
# library(cowplot)
# 
# base_plot <- 
#   plot_cme(m6_out_dem_int, 
#          variables = "log_cc_outs", 
#          condition = "vdem_polyarchy",
#          conf_level = 0.95) +
# ggtitle("Marginal Effect at the Mean of Pollution Outsourcing") +
# theme_bw() +
# theme(panel.border = element_blank(),
#       axis.title.x = element_text(size = 15),
#       axis.title.y = element_text(size = 15),
#       axis.text = element_text(size = 13),
#       plot.title = element_text(size = 17, face = "bold", hjust = 0.5)) +
# geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
# xlab("Democracy") +
# ylab("Marginal Effect of Pollution Outsourcing")
# 
# # Create the histogram plot for the x-axis variable
# hist_plot <- ggplot(data_s, aes(x = vdem_polyarchy)) +
#   geom_histogram(bins = 30, fill = viridis(1, alpha = 0.25), color = viridis(1, alpha = 0.75)) +
#   theme_void() 
# 
# # Combine the base plot and histogram plot using cowplot
# combined_plot <- ggdraw() +
#   draw_plot(base_plot, x = 0, y = 0, width = 1, height = 0.8) +
#   draw_plot(hist_plot, x = 0.09, y = 0.07, width = 0.9, height = 0.2)
# 
# # Print the combined plot
# pdf("plots/Marginal_outsource_dem_1.pdf")
# par(mar = c(2.5, 2.4,0, 2.1)) # c(bottom, left, top, right))
# combined_plot
# dev.off()


pdf("plots/Marginal_outsource_dem_2.pdf")

interplot(m8_out_dem_int_c,
          var1 = "log_cc_outs",
          var2 = "vdem_polyarchy",
          hist = T,
          ci = 0.95,
          sims = 1000,
          ercolor = viridis(1, alpha = 0.75),
          rfill = viridis(1, alpha = 0.05),
          ralpha = 0.25) +
  xlab("Democracy") +
  ylab("Marginal Effect") +
  ggtitle("Marginal Effect at the Mean of Pollution Outsourcing") +
  theme_bw() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  theme(axis.line = element_line(colour = "black"),
        axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text = element_text(size = 13),
        plot.title = element_text(size = 17, hjust = 0.5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

dev.off()

```


## Simulate expected values and first differences: Model group 1

```{r expected values 1}

#-------------------------------------------------------------------------------
# Get X for observed value approach
#-------------------------------------------------------------------------------
extract_ccode <- m3_outsource_c$model$`as.factor(ccode)` ## extract included countries
extract_year <- m3_outsource_c$model$`as.factor(year)`   ## extract included years

## Create dummy variables for countries and years
data_ova <- dummy_cols(data_s[which(data_s$ccode %in% extract_ccode &  
                                    data_s$year %in% extract_year),],
                       select_columns = c("ccode", "year"))



## Reduce to correct length
data_ova <- data_ova[which(!is.na(data_ova$vdem_polyarchy) &
                           !is.na(data_ova$log_cc_outs) &
                           !is.na(data_ova$log_pop) &
                           !is.na(data_ova$log_gdp_pc)),]

## make sure to select correct columns for the dummies
first_year <- which(colnames(data_ova) == "year_1991")
last_year <- which(colnames(data_ova) == "year_2015")
first_ccode <- which(colnames(data_ova) == "ccode_8")
last_ccode <- which(colnames(data_ova) == "ccode_894")

## Get X
X <- as.matrix(cbind(1,
                     data_ova$vdem_polyarchy, 
                     data_ova$log_pop,
                     data_ova$log_gdp_pc,
                     data_ova$log_gdp_pc_sq,
                     data_ova[,c(first_year:last_year)],
                     data_ova[,c(first_ccode:last_ccode)]))

## Check dimensions
X <- na.omit(X)
dim(X)

## Get colnames
colnames(X) <- names(coef(m3_outsource_c))

#-------------------------------------------------------------------------------
# Install simulation github Rittmann et al. (2023)
#-------------------------------------------------------------------------------
install_github("mneunhoe/simloglm")
library (simloglm)

## Function to sample from inverse gamma distribution
rinvgamma <- function(n, shape, rate = 1, scale = 1/rate){
  if(missing(rate) && !missing(scale))
    rate <- 1/scale
  1/stats::rgamma(n, shape, rate)
}

## Set up informal posterior of coefficients
nsim <- 1000 # number of draws
beta_hat <- coef(m3_outsource_c)
sigma_hat <- summary(m3_outsource_c)$sigma
X_prime_X <- summary(m3_outsource_c)$cov.unscaled

## First sigma^2
set.seed(199610)
sigma2_tilde <- rinvgamma(nsim,
                          shape = m3_outsource_c$df.residual/2,
                          rate = (sigma_hat^2*m3_outsource_c$df.residual)/2)

# Now the betas
beta_tilde <- matrix(NA,
                     nrow = nsim,
                     ncol = length(beta_hat))

for(sim in 1:nsim){
  beta_tilde[sim, ] <-
    MASS::mvrnorm(1, beta_hat, X_prime_X * sigma2_tilde[sim])
}


#-------------------------------------------------------------------------------
# Set scenarios: over range of democracy
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Determine "reasonable" variation of democracy variable
range_dem <- aggregate(data_ova$vdem_polyarchy,
                       by = list(data_ova$cname),
                       FUN = range)

names(range_dem) <- c("country", "range")

# get the difference
range_dem$diff <- range_dem$range[,2]- range_dem$range[,1]

# get the respective country
max_range_dem_country <- range_dem$country[which.max(range_dem$diff)]

# and the respective values (min and max > used for setting the scenario)
min_dem <- range_dem$range[,1][which.max(range_dem$diff)]
max_dem <- range_dem$range[,2][which.max(range_dem$diff)]

range_dem <- as.vector(seq(min_dem, max_dem, length.out = 30))


# Create empty matrix to store the scenarios
cases <- array(NA, 
               c(dim(X), length(range_dem)))

# Copy in our X
cases[,,] <- X # because OVA not Average case!

# Select: Democracy over range
select <- which(colnames(X) == "vdem_polyarchy")

for(i in 1:length(range_dem)){
  cases[ ,select, i] <- range_dem[i]
}

head(cases)
dim(cases) 

# check dimensions 
# 3933 rows/datapoints
# 190 variables (incl. country and year dummies)
# 30 scenarios

# Calculate linear predictor on log scale & retransform
E_Y_c_dem <- matrix(NA, nrow = nsim, ncol = length(range_dem)) # empty matrix for storage

for(i in 1:length(range_dem)){              # 30 rounds (for range of dem variable)
  ev <- beta_tilde %*% t(cases[,,i])        # calculate linear predictor on log scale
  ev_plus_gamma <- ev + 1/2*sigma2_tilde    # add draws of 1/2*sigma2_tilde
  ev_transf <- exp(ev_plus_gamma)           # transform
  ev_transf_m <- ev_transf #- 1              # E(y) - 1
  tmp_val <- apply(ev_transf_m, 1, mean)    # now average results
  E_Y_c_dem[,i] <- tmp_val                  # store in val object
}

# Summarize to get CIs
CI_E_Y_c_dem <- apply(E_Y_c_dem, 2, quantile, c(0.025, 0.975))

# Now get the point estimates 
E_Y_c_hat_dem <- matrix(NA, nrow = length(range_dem), ncol = 1)

for(i in 1:length(range_dem)){                         # 30 rounds (for range of dem variable)
  ev_point <- beta_hat %*% t(cases[,,i])               # use beta_hat (not simulated)
  ev_point_plus_gamma <- ev_point + 1/2*sigma_hat^2    # use sigma_hat (not simulated)
  ev_point_transf <- exp(ev_point_plus_gamma)          # transform
  ev_point_transf_m <- ev_point_transf #- 1             # E(y) - 1
  tmp_val_point <- apply(ev_point_transf_m, 1, mean)   # now average results
  E_Y_c_hat_dem[i,] <- tmp_val_point                   # store in val object
}


#-------------------------------------------------------------------------------
# Plot: Expected values of pollution outsourcing (on original scale)
#-------------------------------------------------------------------------------

pdf("plots/Expected value_dem.pdf") 

par(mar = c(5.1, 4.7, 4.1, 2.1)) # c(bottom, left, top, right))

plot(range_dem,
     E_Y_c_hat_dem,
     type = "n",
     ylim = c(59, 75),
     xlim = c(min_dem, max_dem),
     ylab = expression("Pollution Outsourcing [Gg]"),
     xlab = "Democracy",
     bty = "n",
     main = NULL,
     cex.lab = 1.3)

segments(x0 = range_dem, x1 = range_dem,
         y1 = CI_E_Y_c_dem[2,], y0 = CI_E_Y_c_dem[1,],
         col = viridis(1, 0.25),
         lwd = 4, lend = 1)

points(range_dem, E_Y_c_hat_dem, col = viridis(1, 0.8), pch = 20,
       cex = 1.5)


# Add a "histogram" of actual X1-values.
axis(1,
     at = data_ova$vdem_polyarchy,
     col.ticks = "gray30",
     labels = FALSE,
     tck = 0.02)

dev.off()


#-------------------------------------------------------------------------------
# First difference
#-------------------------------------------------------------------------------

## First difference: Democracy high - low
FD_dem_hat <- E_Y_c_hat_dem[30,] - E_Y_c_hat_dem[1,]  ## max - min
FD_dem <- E_Y_c_dem[,30] - E_Y_c_dem[,1] 
CI_FD_dem <- quantile(FD_dem, c(0.025, 0.975))


#-------------------------------------------------------------------------------
## How "big" is the difference compared to variation in the dataset?
#-------------------------------------------------------------------------------
sd_outs <- aggregate(data_ova$cf_cc_pop_mean_outs,
                     by = list(data_ova$cname),
                     FUN = sd)

mean_within_country_sd <- mean(sd_outs[,2], na.rm = T)
share_FD_var <- FD_dem_hat / mean_within_country_sd

```

## Simulate expected values and first differences: Model group 2

```{r expected values 2}

#-------------------------------------------------------------------------------
# Get X for observed value approach
#-------------------------------------------------------------------------------
extract_ccode2 <- m8_out_dem_int_c$model$`as.factor(ccode)` ## extract included countries
extract_year2 <- m8_out_dem_int_c$model$`as.factor(year)`   ## extract included years

## Create dummy variables for countries and years
data_ova2 <- dummy_cols(data_s[which(data_s$ccode %in% extract_ccode2 &  
                                     data_s$year %in% extract_year2),],
                        select_columns = c("ccode", "year"))



## Reduce to correct length
data_ova2 <- data_ova2[which(!is.na(data_ova2$vdem_polyarchy) &
                             !is.na(data_ova2$log_cc_outs) &
                             !is.na(data_ova2$log_pop) &
                             !is.na(data_ova2$log_gdp_pc) &
                             !is.na(data_ova2$log_pm25_pop)),]

## make sure to select correct columns for the dummies
first_year2 <- which(colnames(data_ova2) == "year_1999")
last_year2 <- which(colnames(data_ova2) == "year_2015")
first_ccode2 <- which(colnames(data_ova2) == "ccode_8")
last_ccode2 <- which(colnames(data_ova2) == "ccode_894")

## Get X
X2 <- as.matrix(cbind(1,
                      data_ova2$log_cc_outs,
                      data_ova2$vdem_polyarchy, 
                      data_ova2$log_pop,
                      data_ova2$log_gdp_pc,
                      data_ova2$log_gdp_pc_sq,
                      data_ova2[,c(first_year2:last_year2)],
                      data_ova2[,c(first_ccode2:last_ccode2)],
                      data_ova2$log_cc_outs * data_ova2$vdem_polyarchy))

## Check dimensions
X2 <- na.omit(X2)
dim(X2)

## Get colnames
colnames(X2) <- names(coef(m8_out_dem_int_c))

#-------------------------------------------------------------------------------
# Follow Rittmann et al.'s instructions
#-------------------------------------------------------------------------------

## Set up informal posterior of coefficients
beta_hat2 <- coef(m8_out_dem_int_c)
sigma_hat2 <- summary(m8_out_dem_int_c)$sigma
X_prime_X2 <- summary(m8_out_dem_int_c)$cov.unscaled

## First sigma^2
set.seed(199610)
sigma2_tilde2 <- rinvgamma(nsim,
                           shape = m8_out_dem_int_c$df.residual/2,
                           rate = (sigma_hat2^2*m8_out_dem_int_c$df.residual)/2)

# Now the betas
beta_tilde2 <- matrix(NA,
                      nrow = nsim,
                      ncol = length(beta_hat2))

for(sim in 1:nsim){
  beta_tilde2[sim, ] <-
    MASS::mvrnorm(1, beta_hat2, X_prime_X2 * sigma2_tilde2[sim])
}


#-------------------------------------------------------------------------------
# Determine "reasonable" variation of outsourcing
range_outsource <- aggregate(data_ova$log_cc_outs,
                             by = list(data_ova$cname),
                             FUN = range)

names(range_outsource) <- c("country", "range")

# get the difference
range_outsource$diff <- range_outsource$range[,2]-range_outsource$range[,1]

# get the respective country
max_range_outsource_country <- range_outsource$country[which.max(range_outsource$diff)]

# and the respective values (min and max > used for setting the scenario)
min_outsource <- range_outsource$range[,1][which.max(range_outsource$diff)]
max_outsource <- range_outsource$range[,2][which.max(range_outsource$diff)]


#-------------------------------------------------------------------------------
## Create empty matrix to store the scenarios
cases2 <- array(NA, 
                c(dim(X2), 4))

## Copy in our X
cases2[,,] <- X2 

## Add names
colnames(cases2) <- names(beta_hat2)

## Case 1: min dem & min outsource
cases2[ ,"vdem_polyarchy", 1] <- min_dem
cases2[ ,"log_cc_outs", 1] <- min_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 1] <- min_dem*min_outsource

## Case 2: min dem & max outsource
cases2[ ,"vdem_polyarchy", 2] <- min_dem
cases2[ ,"log_cc_outs", 2] <- max_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 2] <- min_dem*max_outsource

## Case 3: max dem & min outsource
cases2[ ,"vdem_polyarchy", 3] <- max_dem
cases2[ ,"log_cc_outs", 3] <- min_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 3] <- max_dem*min_outsource

## Case 4: max dem & max outsource
cases2[ ,"vdem_polyarchy", 4] <- max_dem
cases2[ ,"log_cc_outs", 4] <- max_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 4] <- max_dem*max_outsource


#-------------------------------------------------------------------------------
## Calculate linear predictor on log scale & retransform
#-------------------------------------------------------------------------------
E_Y_c2 <- matrix(NA, nrow = nsim, ncol = 4)  # empty matrix for storage

for(i in 1:4){                              # four rounds (for scenarios)
  ev <- beta_tilde2 %*% t(cases2[,,i])      # calculate linear predictor on log scale
  ev_plus_gamma <- ev + 1/2*sigma2_tilde2   # add draws of 1/2*sigma2_tilde
  ev_transf <- exp(ev_plus_gamma)           # transform
  ev_transf_m <- ev_transf                  # E(y) 
  tmp_val <- apply(ev_transf_m, 1, mean)    # now average results
  E_Y_c2[,i] <- tmp_val                     # store in val object
}

## Summarize to get CIs
CI_E_Y_c2 <- apply(E_Y_c2, 2, quantile, c(0.025, 0.5, 0.975))

## Now get the point estimates 
E_Y_c_hat2 <- matrix(NA, nrow = 4, ncol = 1)

for(i in 1:4){                                       # four rounds (for scenarios)
  ev_point <- beta_hat2 %*% t(cases2[,,i])           # use beta_hat (not simulated)
  ev_point_plus_gamma <- ev_point + 1/2*sigma_hat^2  # use sigma_hat (not simulated)
  ev_point_transf <- exp(ev_point_plus_gamma)        # transform
  ev_point_transf_m <- ev_point_transf               # E(y)
  tmp_val_point <- apply(ev_point_transf_m, 1, mean) # now average results
  E_Y_c_hat2[i,] <- tmp_val_point                    # store
}


#-------------------------------------------------------------------------------
## First differences
#-------------------------------------------------------------------------------

## First difference: Democracy low -> Outsource max - min
FD_dem_low_hat <- E_Y_c_hat2[2,] - E_Y_c_hat2[1,]  ## max - min
FD_dem_low <- E_Y_c2[,2] - E_Y_c2[,1] 
CI_FD_dem_low <- quantile(FD_dem_low, c(0.025, 0.975))

## First difference: Democracy high -> Outsource max - min
FD_dem_high_hat <- E_Y_c_hat2[4,] - E_Y_c_hat2[3,]  ## max - min
FD_dem_high <- E_Y_c2[,4] - E_Y_c2[,3] 
CI_FD_dem_high <- quantile(FD_dem_high, c(0.025, 0.975))

## First difference of first difference
FD_FD_hat <- FD_dem_high_hat - FD_dem_low_hat
FD_FD <- FD_dem_high - FD_dem_low
CI_FD_FD <- quantile(FD_FD, c(0.025, 0.975))

#-------------------------------------------------------------------------------
## How "big" is the difference compared to variation in the dataset?
#-------------------------------------------------------------------------------
sd_pm25 <- aggregate(data_ova2$populationweightedpm25ugm3,
                     by = list(data_ova2$cname),
                     FUN = sd)

mean_pm25_country_sd <- mean(sd_pm25[,2], na.rm = T)
mean_pm25_sd_between <- sd(data_ova2$populationweightedpm25ugm3)
share_FD_low_var <- FD_dem_low_hat / mean_pm25_country_sd
share_FD_high_var <- abs(FD_dem_high_hat) / mean_pm25_country_sd
share_FD_FD_var <- abs(FD_FD_hat) / mean_pm25_country_sd
share_FD_FD_between <- abs(FD_FD_hat) / mean_pm25_sd_between


#-------------------------------------------------------------------------------
## Plot First differences
#-------------------------------------------------------------------------------
pdf("plots/FDs_dem_high_low.pdf")

plot(y = 1,
     x = FD_dem_low_hat,
     col = viridis(3)[1],
     ylim = c(0,3),
     xlim = c(-1,21),
     xlab = expression("PM"[2.5]*" [micrograms per cubicmeter]"),
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1, x0 = CI_FD_dem_low[1],
         y1 = 1, x1 = CI_FD_dem_low[2],
         col = viridis(3, alpha = 0.4)[1],
         lwd = 12, cex = 1.5, lend = 1)

segments(y0 = 2, x0 = CI_FD_dem_high[1],
         y1 = 2, x1 = CI_FD_dem_high[2],
         col = viridis(3, alpha = 0.4)[1],
         lwd = 12, cex = 1.5, lend = 1)

points(y = 2,
       x = FD_dem_high_hat,
       col = viridis(3)[1],
       xlab = "",
       pch = 19,
       main = NULL, 
       bty = "n",
       ylab = "",
       yaxt = "n",
       cex = 3,
       cex.lab = 1.1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 3,
         lty = "dashed", lwd = 2)

text(x = FD_dem_low_hat,
     y = 0.8,
     labels = c("Non-democratic"),
     cex = 1.1)

text(x = FD_dem_low_hat,
     y = 0.57,
     labels = c("Outsourcing (max - min)"),
     cex = 0.9)

text(x = FD_dem_high_hat-0.35,
     y = 1.8,
     labels = c("Democratic"),
     cex = 1.1)

text(x = FD_dem_high_hat-0.35,
     y = 1.57,
     labels = c("Outsourcing (max - min)"),
     cex = 0.9)

dev.off()

## First difference of first difference
pdf("plots/FD_FD.pdf")

plot(y = 1.5,
     x = FD_FD_hat,
     col = viridis(3)[2],
     ylim = c(0,3),
     xlim = c(-10,0.75),
     xlab = expression("PM"[2.5]*" [micrograms per cubicmeter]"),
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1.5, x0 = CI_FD_FD[1],
         y1 = 1.5, x1 = CI_FD_FD[2],
         col = viridis(3, alpha = 0.4)[2],
         lwd = 12, cex = 1.5, lend = 1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 3,
         lty = "dashed", lwd = 2)

text(x = FD_FD_hat,
     y = 1.26,
     labels = c("FD of FD"),
     cex = 1.1)

text(x = FD_FD_hat,
     y = 1.05,
     labels = c("Democracy (high-low)"),
     cex = 0.9)

dev.off()

```


# Robustness

## Temporally lagged DV

```{r lagged DV}

#-------------------------------------------------------------------------------
# Lag DV
#-------------------------------------------------------------------------------
# lag co2
data_non_oecd <- data_non_oecd %>%
  group_by(ccode) %>%
  arrange(year) %>%
  mutate(lag_wdi_co2 = dplyr::lag(wdi_co2))


```

## Replacing DV with ecological footprint data

```{r DV ecolog footprint}

#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_eco <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_eco_int <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy + 
                  export_fdi_index * vdem_polyarchy + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_eco_c <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_eco_int_c <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy + 
                    export_fdi_index * vdem_polyarchy  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_eco, m3_eco_int, m3_eco_c, m3_eco_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(Ecological footprint)",
          covariate.labels = c("ln(Ecological footprint)$_{t-1}$", "Export-FDI index",
                               "Electoral democracy", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Electoral dem.", "Constant"))
``` 

## Replacing DV with changes in CO2

```{r DV CO2 change}

#-------------------------------------------------------------------------------
# Calculate (lagged) change variable
#-------------------------------------------------------------------------------
data_s$co2change <- data_s$lag_wdi_co2 - data_s$wdi_co2

# lag change co2
data_s <- data_s %>%
  group_by(ccode) %>%
  arrange(year) %>%
  mutate(lag_co2change = dplyr::lag(co2change))


#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_co2c <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_co2c_int <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy + 
                  export_fdi_index * vdem_polyarchy + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_co2c_c <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_co2c_int_c <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy + 
                    export_fdi_index * vdem_polyarchy  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_co2c, m3_co2c_int, m3_co2c_c, m3_co2c_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "Change ln(CO$_2$ emissions per capita)",
          covariate.labels = c("Change ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Electoral democracy", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Electoral dem.", "Constant"))

``` 

## Replacing Democracy variable: Freedom House & Polity V

```{r IV Freedom House and Polity V}

#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_fh <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_fh_int <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl + 
                  export_fdi_index * fh_cl + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_fh_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_fh_int_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl + 
                    export_fdi_index * fh_cl  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_fh, m3_fh_int, m3_fh_c, m3_fh_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(CO$_2$ emissions per capita)",
          covariate.labels = c("ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Dem. (Freedom House)", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Dem. (Freedom House).", "Constant"))


#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_pol <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_pol_int <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 + 
                  export_fdi_index * p_polity2 + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_pol_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_pol_int_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 + 
                    export_fdi_index * p_polity2  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_pol, m3_pol_int, m3_pol_c, m3_pol_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(CO$_2$ emissions per capita)",
          covariate.labels = c("ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Dem. (Polity V)", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Dem. (Polity V).", "Constant"))

summary(data$fh)
``` 

## Additional controls: Political globaliz. & env. treaties

```{r additional controls}

#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_add_int <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy +
                   as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_add_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy +
                env_treaties + dr_pg + gdp_pc_log + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_add_int_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                    export_fdi_index * vdem_polyarchy  +
                    env_treaties + dr_pg + gdp_pc_log + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_add_int, m3_add_c, m3_add_int_c),
          omit = c("ccode", "year"), type = "text",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(CO$_2$ emissions per capita)",
          covariate.labels = c("ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Electoral democracy", "Environm. treaties", "Political globaliz.", 
                               "ln(GDP per cap.)", "ln(Pop. size)",
                               "Export-FDI index x Electoral dem.", "Constant"))

``` 

## FDI >= 0

```{r FDI restricted}

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_ind_int_restr <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                         export_fdi_index * vdem_polyarchy + 
                         as.factor(year) + as.factor(ccode),
                       data = data_s[which(data_s$wdi_fdiin >= 0),])

stargazer(m3_ind_int_restr, type = "text", omit = c("ccode", "year"))

```

## No lagged DV

```{r no lagged DV}

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_ind_int_no_lag <- lm(log_wdi_co2 ~ export_fdi_index + vdem_polyarchy + 
                         export_fdi_index * vdem_polyarchy + 
                         as.factor(year) + as.factor(ccode),
                       data = data_s)

stargazer(m3_ind_int_no_lag, type = "text", omit = c("ccode", "year"))

```

## Checking autocorrelation and panel-corrected SEs

```{r autocorr}

#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------

## Set up panel data
panel_data <- pdata.frame(data_s, index = c("ccode", "year"))

m3_int_auto <- plm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                     export_fdi_index * vdem_polyarchy,
                    data = panel_data, model = "within", effect = "twoways")

#-------------------------------------------------------------------------------
# Look at summary
#-------------------------------------------------------------------------------
summary(m3_int_auto)

#-------------------------------------------------------------------------------
# Use Breusch-Godfrey test for serial correlation
#-------------------------------------------------------------------------------
bg_test <- bgtest(m3_int_auto)

``` 

## Generalized methods-of-moments dynamic panel estimator

```{r GMM dynamic panel}

#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------

## Set up panel data
panel_data <- pdata.frame(data_s, index = c("ccode", "year"))

## Estimate fixed effects model with individual and time fixed effects
model_fe <- plm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy, 
                data = panel_data, 
                model = "within", 
                effect = "twoways")

m3_int_gmm <- pgmm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy,
                   data = panel_data, 
                   effect = "twoways",
                   model = "twosteps",
                   exo = c("export_fdi_index", "vdem_polyarchy", "export_fdi_index:vdem_polyarchy"),
                   endo = "lag_log_wdi_co2",
                   instruments = c("export_fdi_index", "vdem_polyarchy", 
                                   "export_fdi_index:vdem_polyarchy", 
                                   "year_fe", "country_fe"),
                   gmm.kernel = "two-step")

``` 

## Random effects model

```{r random}

#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------
model_re <- plm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy, 
                data = panel_data, 
                model = "random",
                effect = "individual")

summary(model_re)
```

## Random subsample

```{r subsample}

#-------------------------------------------------------------------------------
# Random subsample
#-------------------------------------------------------------------------------

## get data used for estimation
data_sample <- data_s[which(data_s$export_fdi_index %in% m3_ind_int$model$export_fdi_index),]

## create empty storage object
subsamples <- list()

## set seed
set.seed(19961910)
seeds <- rpois(10, 100)

## get 10 random subsamples of size 1500
for(i in 1:length(seeds)){
 set.seed(seeds[i])
 subsamples[[i]] <- data_sample[sample(1:nrow(data_sample), 1500), ] ## randomly selected rows
}


#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------

## create empty storage object
reg_subsamples <- list()

for(i in 1:10){
reg_subsamples[[i]] <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                           export_fdi_index * vdem_polyarchy + 
                           as.factor(year) + as.factor(ccode),
                          data = subsamples[[i]])
}

## extract relevant beta coefficients and standard errors
mod_summary <- list()
int_est <- matrix(NA,
                    nrow = 10,
                    ncol = 2)

## identify interaction term
number_coefs <- c()

for(i in 1:10){
number_coefs[i] <- nrow(summary(reg_subsamples[[i]])$coefficients)
}

## loop through the 10 regressions and extract
for(i in 1:10){
  mod_summary[[i]] <- summary(reg_subsamples[[i]])
  int_est[i,1:2] <- mod_summary[[i]]$coefficients[number_coefs[i],1:2]
}

## add column names
colnames(int_est)[1:2] <- c("Est.", "SE")

## get sampling distributions of coefficients
set.seed(123456)
nsim <- 1000
sim_int <- matrix(NA,
                    ncol = nrow(int_est),
                    nrow = nsim)

for(j in 1:nrow(int_est)){
  sim_int[,j] <- rnorm(n = nsim,
                         mean = int_est[j,1],
                         sd = int_est[j,2])
}

## get point estimates & CIs
res_int <- matrix(NA,
                    ncol = 3,
                    nrow = nrow(int_est))

for(i in 1:nrow(int_est)){
  res_int[i,] <- quantile(x = sim_int[,i],
                          probs =  c(0.025, 0.5, 0.975))
}

## add column names
colnames(res_int)[1:3] <- c("CI_low", "Est", "CI_up")
res_int <- as.data.frame(res_int)


#-------------------------------------------------------------------------------
# Plot the data
#-------------------------------------------------------------------------------
color_est <- ifelse(res_int$CI_low > 0 & res_int$CI_up < 0|
                    res_int$CI_low < 0 & res_int$CI_up > 0,
                    "darkgrey", viridis(3)[1])

color_ci <- ifelse(res_int$CI_low > 0 & res_int$CI_up < 0|
                   res_int$CI_low < 0 & res_int$CI_up > 0,
                   "darkgrey", viridis(3, alpha = 0.4)[1]) 


pdf("plots/subsamples.pdf")

par(mar = c(5.1, 4.1, 2.5, 2.1)) # c(bottom, left, top, right))

plot(y = rev(c(0.2,0.4, 0.6, 0.8, 1, 1.2,
               1.4, 1.6, 1.8, 2)),
     x = res_int$Est,
     col = color_est,
     ylim = c(0,2.2),
     xlim = c(-0.2,0.3),
     xlab = "Interaction Export-FDI x Democracy",
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 1.5,
     cex.lab = 1.1)

segments(y0 = rev(c(0.2,0.4, 0.6, 0.8, 1, 1.2,
                1.4, 1.6, 1.8, 2)), 
         y1 = rev(c(0.2,0.4, 0.6, 0.8, 1, 1.2,
                1.4, 1.6, 1.8, 2)), 
         x0 = res_int$CI_low,
         x1 = res_int$CI_up,
         col = color_ci,
         lwd = 4, cex = 1.5, lend = 1)

text(x = 0.18,
     y = rev(c(0.2,0.4, 0.6, 0.8, 1, 1.2,
           1.4, 1.6, 1.8, 2)),
     labels = c("1. subsample", "2. subsample",
                "3. subsample", "4. subsample", "5. subsample", "6. subsample",
                "7. subsample", "8. subsample", "9. subsample", "10. subsample"),
     cex = 1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2.5,
         lty = "dashed", lwd = 2)

dev.off()

```
