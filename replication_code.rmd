---
title: "Pollution Outsourcing and Democracy 2"
author: "Ella Henninger"
date: "2023-07-25"
output:
  word_document: default
  html_document: default
---

# Contents of the replication packet

This R-Markdown file replicates all analyses and figures included in the paper "What Makes Democracies Greener? The Role of Pollution Offshoring" by Tobias BÃ¶hmelt, Ella Henninger, and Thomas Bernauer.

## Data
 - **Outsourcing data**: Presberger and Bernauer (2023), https://www.sciencedirect.com/science/article/pii/S0959378023000031?via%3Dihub
 - **Pollution data**: Van Donkelaar et al. (2021), https://pubs.acs.org/doi/full/10.1021/acs.est.1c05309
 - **Main data**: Quality of Governance database (QoG), https://www.gu.se/en/quality-government/qog-data
 - **Economic data**: World Development Indicators (2023), https://databank.worldbank.org/source/world-development-indicators#
 - **Democracy data**: V-Dem (2023), https://www.v-dem.net/data/the-v-dem-dataset/


**The code is structured as follows**:

1. Set up

2. Preparatory steps
2.1 Load data
2.2 Create lagged and logged variables

3. Descriptives
3.1 Table summary statistics
3.2 Correlations

4. Analyses
4.1 Models Democracy and pollution outsourcing
4.2 Models Pollution outsourcing and environmental performance

5. Quantities of interest
5.1 Simulated interaction term and marginal effects
5.2 Expected values outsourcing & first difference: Model group 1
5.3 Expected values & first differences PM2.5: Model group 2

6. Robustness checks
6.1 Replacing DV with ecological footprint data
6.2 Replacing DV with change in CO2
6.3 Replacing democracy variable with Freedom House and Polity V
6.4 Including additional controls: Political globaliz. & Environm. treaties
6.5 Restricting data to FDI inflow >= 0
6.6 Excluding lagged DV
6.7 Checking for autocorrelation and panel-corrected SEs
6.8 GGM dynamic panel estimator
6.9 Random effects model
6.10 Random subsamples

**As a note**: You may be asked to update some packages, please press "yes" to make sure the file runs smoothly.


# Set up

```{r setup, include=FALSE}

## clean environment
rm(list = ls())

# Define which packages needed for analyses
p_needed <-
  c("knitr",
    "dplyr", 
    "psych",
    "stargazer",
    "ggplot2",
    "viridis",
    "haven",
    "MASS",
    "modelsummary",
    "WDI",
    "plm",
    "lmtest",
    "ggmap",
    "maps",
    "tidyr",
    "devtools",
    "data.table",
    "sjPlot",
    "interplot",
    "fastDummies",
    "texreg")

# Check which packages are already installed on your computer
packages <- rownames(installed.packages())

# Check which packages are not installed
p_to_install <- p_needed[!(p_needed %in% packages)]

if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_needed, require, character.only = TRUE)


# Set an option for the final document that can be produced from the .Rmd file.
knitr::opts_chunk$set(echo = TRUE)

## For replicability: session information 
session_info <- print(sessionInfo())

```



# Preparatory steps

## Load data

```{r load data}

#-------------------------------------------------------------------------------
# Data
#-------------------------------------------------------------------------------
data <- read_dta("data/QoG/qog_std_ts_jan23_stata14.dta")

#-------------------------------------------------------------------------------
# Filter data
#-------------------------------------------------------------------------------
data <- data[which(data$year >= 1989),]
data <- data[which(data$year <= 2022),]

```

## Create lagged and logged variables 

```{r variable selection}

#-------------------------------------------------------------------------------
# Create logs
#-------------------------------------------------------------------------------
data$insourced_GHG <- data$cf_cc_pop_mean
data$log_wdi_co2 <- log(1 + data$wdi_co2)  ## plus 1 to avoid negative numbers

## outsourced CO2
data$log_cc_outs <- log(data$cf_cc_pop_mean_outs)

## pm2.5
data$log_pm25_pop <- log(data$populationweightedpm25ugm3)
data$log_pm25_geo <- log(data$geographicmeanpm25ugm3)

## carbon footprint of consumption
data$log_ef_carb <- log(data$ef_carb)

## population
data$log_pop <- log(data$wdi_pop)
data$log_pop_den <- log(data$wdi_popden)

## gdp
data$log_gdp_pc <- log(data$wdi_gdpcapcon2015)
data$log_gdp_pc_sq <- data$log_gdp_pc^2
data$log_gdp <- log(data$wdi_gdppppcon2017)


#-------------------------------------------------------------------------------
# Create environmental treaties variable
#-------------------------------------------------------------------------------
data <- data %>% 
  group_by(ccode) %>% 
  mutate(env_treaties = ifelse(any(!is.na(iea_sum_i)), zoo::na.locf(iea_sum_i), NA))

data$env_treaties <- data$env_treaties/100

#-------------------------------------------------------------------------------
# Transform Freedom House civil liberties variable
#-------------------------------------------------------------------------------
data$fh_cl <- 8 - data$fh_cl

#-------------------------------------------------------------------------------
# Create environmental treaties variable
#-------------------------------------------------------------------------------
data <- data %>% 
  group_by(ccode) %>% 
  mutate(env_treaties = ifelse(any(!is.na(iea_sum_i)), zoo::na.locf(iea_sum_i), NA))

data$env_treaties <- data$env_treaties/100

#-------------------------------------------------------------------------------
# Rescale political globalization variable (1-10)
#-------------------------------------------------------------------------------
data$dr_pg <- data$dr_pg/100

#-------------------------------------------------------------------------------
# Subset data to relevant variables
#-------------------------------------------------------------------------------
data_s <- dplyr::select(data, "cname", "ccode", "year", "ccodealp", 
                              "insourced_GHG", "cf_cc_pop_mean", "cf_cc_pop_mean_outs", "log_cc_outs",
                              "log_pm25_pop", "log_pm25_geo", "log_wdi_co2",
                              "populationweightedpm25ugm3", "geographicmeanpm25ugm3",
                              "ef_carb", "log_ef_carb",
                              "vdem_polyarchy", "log_gdp_pc", "log_gdp_pc_sq", "log_gdp",
                              "log_pop", "log_pop_den", "fh_cl", "fh_fog",
                              "cf_bw_pop_mean_outs", "cf_en_pop_mean_outs", "cf_lu_pop_mean_outs", "cf_mf_pop_mean_outs",
                              "dr_pg", "fh_status", "env_treaties",  "wdi_trade",
                              "p_polity2", "vdem_partip", "vdem_delibdem", "wdi_gdpind")

```



# Descriptives

## Table summary statistics

```{r descriptives}

#-------------------------------------------------------------------------------
# Table: Summary statistics
#-------------------------------------------------------------------------------
data_descript <- data_s[which(!is.na(data_s$log_cc_outs) &
                              data_s$log_ef_carb != -Inf),]
# 
# options("modelsummary_format_numeric_latex" = "plain")
# datasummary(formula = (`Pollution Outsourcing` = cf_cc_pop_mean_outs) + (`ln(Pollution Outsourcing)` = log_cc_outs) +
#                       (`PM2.5 (pop. weighted)` = populationweightedpm25ugm3) + (`ln(PM2.5) (pop. weighted)` = log_pm25_pop) +
#                       (`PM2.5 (geo. mean)` = geographicmeanpm25ugm3) +  (`ln(PM2.5) (geo. mean)` = log_pm25_geo) +
#                       (`ln(CO2)` = log_wdi_co2) +  (`ln(Environm. Footprint Consumpt.)` = log_ef_carb) +
#                       (`Democracy` = vdem_polyarchy) + (`ln(GDP)` = log_gdp) +
#                       (`ln(GDP per capita)` = log_gdp_pc) + (`ln(Populat. Size)`= log_pop) +
#                       (`Civil liberties (Freedom House)` = fh_cl) +
#                       (`Democracy (Polity V)` = p_polity2) + (`Political Globaliz.` = dr_pg) +
#                       (`Trade Openness` = wdi_trade) + (`Environm. Treaties` = env_treaties)
#               ~ N + Mean + SD + Min + Median + Max,
#             title = "Summary statistics",
#             data = data_descript,
#             output = "latex")

```

## Correlations

```{r correlations}

#-------------------------------------------------------------------------------
## Correlation heat map
#-------------------------------------------------------------------------------
data_cor <- data_descript[,c("log_cc_outs", "log_pm25_pop", "log_wdi_co2", "log_ef_carb",
                             "vdem_polyarchy", "log_gdp", "log_gdp_pc", "log_pop", 
                             "fh_cl", "p_polity2", "wdi_trade", "env_treaties", "dr_pg", "wdi_gdpind")]

data_cor <- na.omit(data_cor)

cormat <- round(cor(data_cor), 2)
melted_cormat <- melt(cormat)

ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  scale_fill_gradient2(midpoint= 0, 
                       low = viridis(3)[1], 
                       mid = "white",
                       high = viridis(3)[2], 
                       na.value = "grey50", space ="Lab") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  geom_tile()


#-------------------------------------------------------------------------------
## Correlation pm2.5 & outsourcing
#-------------------------------------------------------------------------------
cor(data_cor$log_pm25_pop, data_cor$log_cc_outs) ## -0.30
cor(data_cor$log_pm25_pop, data_cor$log_wdi_co2) ## -0.27
cor(data_cor$log_pm25_pop, data_cor$log_ef_carb) ## -0.35

```

## Trends

```{r trends}

#-------------------------------------------------------------------------------
## Differentiate inequality increasing / decreasing countries over time
#-------------------------------------------------------------------------------

## create lead variable
data_trend <- data_s %>%
  group_by(ccode) %>%
  arrange(year)%>%
  mutate(lead_cc_outs = dplyr::lead(cf_cc_pop_mean_outs),
         lead_pm25 = dplyr::lead(populationweightedpm25ugm3),
         lead_democracy = dplyr::lead(vdem_polyarchy))    

## name columns
data_trend <- data_trend[,c("ccode", "year", "cf_cc_pop_mean_outs", "lead_cc_outs",
                            "populationweightedpm25ugm3", "lead_pm25", "vdem_polyarchy", "lead_democracy")]

## add inequality trend column
data_trend$trend_outsource <- NA
data_trend$trend_pollution <- NA
data_trend$trend_democracy <- NA

## get variable that indicates increase vs. decrease in t+1 compared to t
for(i in 1:nrow(data_trend)){
data_trend$trend_outsource[i] <- ifelse((!is.na(data_trend$lead_cc_outs[i]) & !is.na(data_trend$cf_cc_pop_mean_outs[i])),     # if both top10 and lead top10 not NA
                                         (data_trend$lead_cc_outs[i] - data_trend$cf_cc_pop_mean_outs[i]), NA)                # insert diff between them 

data_trend$trend_pollution[i] <- ifelse((!is.na(data_trend$lead_pm25[i]) & !is.na(data_trend$populationweightedpm25ugm3[i])),     # if both top10 and lead top10 not NA
                                         (data_trend$lead_pm25[i] - data_trend$populationweightedpm25ugm3[i]), NA)                # insert diff between them 

data_trend$trend_democracy[i] <- ifelse((!is.na(data_trend$lead_democracy[i]) & !is.na(data_trend$vdem_polyarchy[i])),     # if both top10 and lead top10 not NA
                                         (data_trend$lead_democracy[i] - data_trend$vdem_polyarchy[i]), NA)                # insert diff between them 
}

## get overall trend (more increasing vs. more decreasing years)
summary_trend_outsource <- data_trend %>%
  group_by(ccode) %>%
  summarize(sum_trend_outsource = ifelse(all(is.na(trend_outsource)), NA, sum(trend_outsource, na.rm = TRUE)),
            var_trend_outsource = ifelse(all(is.na(trend_outsource)), NA, var(trend_outsource, na.rm = TRUE))) 

summary_trend_pollution <- data_trend %>%
  group_by(ccode) %>%
  summarize(sum_trend_pollution = ifelse(all(is.na(trend_pollution)), NA, sum(trend_pollution, na.rm = TRUE)),
            var_trend_pollution = ifelse(all(is.na(trend_pollution)), NA, var(trend_pollution, na.rm = TRUE))) 

summary_trend_democracy <- data_trend %>%
  group_by(ccode) %>%
  summarize(sum_trend_democracy = ifelse(all(is.na(trend_democracy)), NA, sum(trend_democracy, na.rm = TRUE)),
            var_trend_democracy = ifelse(all(is.na(trend_democracy)), NA, var(trend_democracy, na.rm = TRUE))) 


## colnames
colnames(summary_trend_outsource)[1:3] <- c("ccode", "trend_outsource", "var_trend_outsource")
colnames(summary_trend_pollution)[1:3] <- c("ccode", "trend_pollution", "var_trend_pollution")
colnames(summary_trend_democracy)[1:3] <- c("ccode", "trend_democracy", "var_trend_democracy")

## combine
data_s <- left_join(data_s, summary_trend_outsource, by = "ccode")
data_s <- left_join(data_s, summary_trend_pollution, by = "ccode")
data_s <- left_join(data_s, summary_trend_democracy, by = "ccode")


summary(data_s$trend_outsource)
summary(data_s$trend_pollution)
summary(data_s$trend_democracy)
summary(data_s$var_trend_outsource)
summary(data_s$var_trend_pollution)
summary(data_s$var_trend_democracy)

## clean up
remove(data_trend)


#-------------------------------------------------------------------------------
# Plot trend variable
#-------------------------------------------------------------------------------
min_diff <- round(min(data_s$trend_pollution, na.rm = TRUE), digits = 2)
max_diff <- round(max(data_s$trend_pollution, na.rm = TRUE), digits = 2)

pdf("plots/trend_pollution.pdf")

ggplot(data_s[which(!is.na(data_s$trend_pollution)),],
       aes(x = reorder(cname, trend_pollution), y = trend_pollution, fill = trend_pollution >= 0)) +
  theme_minimal() +
  geom_bar(stat = "identity") +
  labs(y = "Change in Pollution", x = "Countries") +

  scale_fill_manual(name = NULL,
                    breaks = c("TRUE", "FALSE"),
                    labels = c("Increase", "Decrease"),
                    values = c(viridis(3)[2], 
                               viridis(3)[1])) +
  
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_text(size = 3),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_text(size = 12),
        legend.position = "bottom", 
        legend.text = element_text(size = 10)) +
  
  # annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
  # annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
  coord_flip()

dev.off()


#-------------------------------------------------------------------------------
# Plot trend variable
#-------------------------------------------------------------------------------
min_diff <- round(min(data_s$trend_outsource, na.rm = TRUE), digits = 2)
max_diff <- round(max(data_s$trend_outsource, na.rm = TRUE), digits = 2)

pdf("plots/trend_outsource.pdf")

ggplot(data_s[which(!is.na(data_s$trend_outsource)),],
       aes(x = reorder(cname, trend_outsource), y = trend_outsource, fill = trend_outsource >= 0)) +
  theme_minimal() +
  geom_bar(stat = "identity") +
  labs(y = "Change in Outsourcing", x = "Countries") +

  scale_fill_manual(name = NULL,
                    breaks = c("TRUE", "FALSE"),
                    labels = c("Increase", "Decrease"),
                    values = c(viridis(3)[2], 
                               viridis(3)[1])) +
  
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_text(size = 3),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_text(size = 12),
        legend.position = "bottom", 
        legend.text = element_text(size = 10)) +
  
  # annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
  # annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
  coord_flip()

dev.off()


#-------------------------------------------------------------------------------
# Plot trend variable
#-------------------------------------------------------------------------------
min_diff <- round(min(data_s$trend_democracy, na.rm = TRUE), digits = 2)
max_diff <- round(max(data_s$trend_democracy, na.rm = TRUE), digits = 2)

pdf("plots/trend_democracy.pdf")

ggplot(data_s[which(!is.na(data_s$trend_democracy)),],
       aes(x = reorder(cname, trend_democracy), y = trend_democracy, fill = trend_democracy >= 0)) +
  theme_minimal() +
  geom_bar(stat = "identity") +
  labs(y = "Change in Democracy", x = "Countries") +

  scale_fill_manual(name = NULL,
                    breaks = c("TRUE", "FALSE"),
                    labels = c("Increase", "Decrease"),
                    values = c(viridis(3)[2], 
                               viridis(3)[1])) +
  
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_text(size = 3),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_text(size = 12),
        legend.position = "bottom", 
        legend.text = element_text(size = 10)) +
  
  # annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
  # annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
  coord_flip()

dev.off()

```



# Analyses

## Create mean and demeaned variables

```{r variable demeaning}

#-------------------------------------------------------------------------------
# Mean and de-meaning
#-------------------------------------------------------------------------------

data_s <- data_s %>%
  group_by(ccode) %>%
  mutate(
    demeaned_log_co2 = log_wdi_co2 - mean(log_wdi_co2, na.rm = T),
    demeaned_log_pm25 = log_pm25_pop - mean(log_pm25_pop, na.rm = T),
    demeaned_log_cc_outs = log_cc_outs - mean(log_cc_outs, na.rm = T),
    demeaned_cc_outs  = cf_cc_pop_mean_outs - mean(cf_cc_pop_mean_outs, na.rm = T),
    demeaned_vdem_poly = vdem_polyarchy - mean(vdem_polyarchy, na.rm = T),
    demeaned_log_pop = log_pop - mean(log_pop, na.rm = T),
    demeaned_log_gdp_pc = log_gdp_pc - mean(log_gdp_pc, na.rm = T),
    demeaned_log_gdp_pc_sq = log_gdp_pc_sq - mean(log_gdp_pc_sq, na.rm = T),
    mean_log_co2 = mean(log_wdi_co2, na.rm = T),
    mean_log_pm25 = mean(log_pm25_pop, na.rm = T),
    mean_log_cc_outs = mean(log_cc_outs, na.rm = T),
    mean_cc_outs = mean(cf_cc_pop_mean_outs, na.rm = T),
    mean_vdem_poly = mean(vdem_polyarchy, na.rm = T),
    mean_log_pop = mean(log_pop, na.rm = T),
    mean_log_gdp_pc = mean(log_gdp_pc, na.rm = T),
    mean_log_gdp_pc_sq = mean(log_gdp_pc_sq, na.rm = T),
    interaction_mean = mean(log_cc_outs, na.rm = T) * mean(vdem_polyarchy, na.rm = T)
  )

summary(data_s$mean_cc_outs)

```

## Within-Between models: Model group 1

```{r within-between 1}

#-------------------------------------------------------------------------------
# Model group 1
#-------------------------------------------------------------------------------
m1_wb <- lmer(log_cc_outs ~ demeaned_vdem_poly + mean_vdem_poly + as.factor(year) +
                (1 | ccode), 
              data = data_s)

m2_wb <- lmer(log_cc_outs ~ demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
               mean_log_pop + mean_log_gdp_pc + mean_log_gdp_pc_sq +
               as.factor(year) + (1 | ccode),
              data = data_s[which(!is.na(data_s$vdem_polyarchy)),])

m3_wb <- lmer(log_cc_outs ~ demeaned_vdem_poly + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
                demeaned_log_pop + 
                mean_vdem_poly + mean_log_gdp_pc + mean_log_gdp_pc_sq + mean_log_pop + as.factor(year) +
                (1 | ccode), 
              data = data_s)

m4_wb <- lmer(log_cc_outs ~ demeaned_vdem_poly + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
                demeaned_log_pop + 
                mean_vdem_poly + mean_log_gdp_pc + mean_log_gdp_pc_sq + mean_log_pop + as.factor(year) +
                (1 | ccode),
               data = data_s[which(!is.na(data_s$log_pm25_pop)),])

stargazer(list(m1_wb, m2_wb, m3_wb, m4_wb), type = "text", omit = c("year"))

## Output
htmlreg(list(m1_wb, m2_wb, m3_wb, m4_wb),
       stars = c(0.01, 0.05, 0.1),
       file = "texreg1.doc",
       custom.header = list("Pollution Outsourcing" = 1:4),
       caption = "Democracy and Pollution Outsourcing",
       label = "tab:table1",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)", 
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)", 
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\ding{51}", "\\ding{51}","\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}")))




#-------------------------------------------------------------------------------
# Coefficient plot 
#-------------------------------------------------------------------------------
pdf("plots/Coefficients_table1_within.pdf", width = 7.5)
par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))

modelplot(m3_wb, 
          coef_map = c("demeaned_log_gdp_pc_sq" = "GDP per capita squ.",
                       "demeaned_log_gdp_pc" = "GDP per capita",
                       "demeaned_log_pop" = "Population",
                       "demeaned_vdem_poly" = "Democracy"),
          color = viridis(3, alpha = 0.75)[1],
          size = 0.9,
          linewidth = 3,
          coef_rename = T) +
  aes(color = ifelse(p.value < 0.05, "Significant", "Not significant")) +
  labs(x = "Within coefficients and 95% confidence intervals") +
  geom_errorbarh(aes(y = term, 
                     xmin = conf.low, 
                     xmax = conf.high,
                     color = viridis(3, alpha = 0.75)[1]),
                 height = 0.2, size = 1.5) +
   scale_color_manual(values = viridis(3, alpha = 0.75)[1]) +
  geom_vline(xintercept = 0, color = "black")


dev.off()


pdf("plots/Coefficients_table1_between.pdf", width = 7.5)
par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))

modelplot(m3_wb, 
          coef_map = c("mean_log_gdp_pc_sq" = "GDP per capita squ.",
                       "mean_log_gdp_pc" = "GDP per capita",
                       "mean_log_pop" = "Population",
                       "mean_vdem_poly" = "Democracy"),
          size = 0.9,
          linewidth = 3,
          coef_rename = T) +
  labs(x = "Between coefficients and 95% confidence intervals") +
  aes(color = ifelse(p.value < 0.05, "Significant", "Not significant")) +
  geom_errorbarh(aes(y = term, 
                     xmin = conf.low, 
                     xmax = conf.high, 
                     color = ifelse(p.value < 0.05, "Significant", "Not significant")),
                 height = 0.2, size = 1.5) +
  scale_color_manual(values = c("grey", viridis(3, alpha = 0.75)[1])) +
  geom_vline(xintercept = 0, color = "black")

dev.off()

```

## Within-Between models: Model group 2

```{r within-between 2}

#-------------------------------------------------------------------------------
# Model group 2
#-------------------------------------------------------------------------------
m5_wb <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
               mean_log_cc_outs + mean_vdem_poly +
               as.factor(year) + (1 | ccode),
              data = data_s)

m6_wb <- lmer(log_wdi_co2 ~ demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
               mean_log_pop + mean_log_gdp_pc + mean_log_gdp_pc_sq + 
               as.factor(year) + (1 | ccode),
              data = data_s[which(!is.na(data_s$log_wdi_co2) &
                                  !is.na(data_s$log_cc_outs) &
                                  !is.na(data_s$vdem_polyarchy)),])

m7_wb <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                mean_log_cc_outs + mean_vdem_poly +
                mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                as.factor(year) + (1 | ccode),
              data = data_s)

stargazer(m5_wb, m6_wb, m7_wb, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Model group 2 - Split by median of democracy variable (within effects)
#-------------------------------------------------------------------------------
data_dem_low <- data_s[which(data_s$vdem_polyarchy < median(data_s$vdem_polyarchy, na.rm = T)),]
data_dem_high <- data_s[which(data_s$vdem_polyarchy >= median(data_s$vdem_polyarchy, na.rm = T)),]

m8_dem_low <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    mean_log_cc_outs + #mean_vdem_poly +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    as.factor(year) + (1 | ccode),
                   data = data_dem_low)

m8_dem_high <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + #mean_vdem_poly +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_dem_high)

stargazer(m8_dem_low, m8_dem_high, type = "text", omit = c("ccode", "year"))
summary(m8_dem_high)


#-------------------------------------------------------------------------------
# Model group 2 - Split by median of mean democracy variable (between effects)
#-------------------------------------------------------------------------------
data_dem_low2 <- data_s[which(data_s$mean_vdem_poly < median(data_s$mean_vdem_poly, na.rm = T)),]
data_dem_high2 <- data_s[which(data_s$mean_vdem_poly >= median(data_s$mean_vdem_poly, na.rm = T)),]

m9_dem_low <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    mean_log_cc_outs + #mean_vdem_poly +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    as.factor(year) + (1 | ccode),
                   data = data_dem_low2)

m9_dem_high <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + #mean_vdem_poly +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_dem_high2)

stargazer(m9_dem_low, m9_dem_high, type = "text", omit = c("ccode", "year"))
summary(m8_dem_high)


# Output
htmlreg(list(m5_wb, m6_wb, m7_wb),
       stars = c(0.01, 0.05, 0.1),
       file = "texreg2.doc",
       custom.header = list("CO$_2$ emissions" = 1:3),
       caption = "Environmental Performance and Pollution Outsourcing",
       custom.model.names = c("Model 5", "Model 6", "Model 7"),
       label = "tab:table2",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}")))


# Output
htmlreg(list(m8_dem_low, m8_dem_high),
       stars = c(0.01, 0.05, 0.1),
       file = "texreg3.doc",
       custom.header = list("CO2 emissions" = 1:2),
       caption = "Environmental Performance and Pollution Outsourcing",
       custom.model.names = c("Low dem.", "High dem."),
       label = "tab:table3",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}")))

texreg(list(m9_dem_low, m9_dem_high),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg4.doc",
       custom.header = list("CO2 emissions" = 1:2),
       caption = "Environmental Performance and Pollution Outsourcing",
       custom.model.names = c("Low dem.", "High dem."),
       label = "tab:table4",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}")))


#-------------------------------------------------------------------------------
# Coefficient plot - Within
#-------------------------------------------------------------------------------

coefs_low <- as.data.frame(summary(m8_dem_low)$coefficients[2:5,])
coefs_high <- as.data.frame(summary(m8_dem_high)$coefficients[2:5,])

# Create data frames for each model
coefs_low$CI_low <- coefs_low[,"Estimate"] - qnorm(0.95)*coefs_low[,"Std. Error"]
coefs_low$CI_high <- coefs_low[,"Estimate"] + qnorm(0.95)*coefs_low[,"Std. Error"]

coefs_high$CI_low <- coefs_high[,"Estimate"] - qnorm(0.95)*coefs_high[,"Std. Error"]
coefs_high$CI_high <- coefs_high[,"Estimate"] + qnorm(0.95)*coefs_high[,"Std. Error"]


pdf("Plots/Coefficients_table2_within.pdf", width = 7.5)

par(mar = c(5.1, 9, 2.5, 2.1)) # c(bottom, left, top, right))

plot(1,
     type = "n",
     ylim = c(0,2.5),
     bty = "n",
     xlab = "Within coefficients and 95% confidence intervals",
     xlim = c(-0.6, 1.5),
     ylab = "",
     yaxt = "n",
     cex.lab = 1.1)


# add grid
segments(x0 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25), y0 = 0,
         x1 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25), y1 = 2.5,
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

segments(x0 = -1.5, y0 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         x1 = 1.5, y1 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

# add null line
segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2.5,
         lty = "solid", lwd = 2, col = "black")


# add point estimates
points(x = coefs_low$Estimate,
       y = rev(c(0.25, 0.75, 1.5, 2.25)),
       pch = 16,
       col = c(viridis(3)[1], "grey", viridis(3)[1], viridis(3)[1]),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         y1 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         col = c(viridis(3, alpha = 0.4)[1], "grey", viridis(3, alpha = 0.4)[1], viridis(3, alpha = 0.4)[1]),
         x0 = coefs_low$CI_low,
         x1 = coefs_low$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add point estimates
points(x = coefs_high$Estimate,
       y = rev(c(0.15, 0.65, 1.4, 2.15)),
       pch = 16,
       col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], viridis(3)[2]),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         y1 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         col = c(viridis(3, alpha = 0.4)[2], viridis(3, alpha = 0.4)[2], viridis(3, alpha = 0.4)[2], viridis(3, alpha = 0.4)[2]),
         x0 = coefs_high$CI_low,
         x1 = coefs_high$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add coefficients text
text(x = -1.25,
     y = rev(c(0.25, 0.75, 1.5, 2.25)),
     labels = c("Pollution outsourcing", "Population", "GDP per capita", "GDP per capita squ."),
     xpd = T,
     cex = 0.9,
     pos = 4)

# Add a legend
legend("topright", 
       legend = c("Less democratic", "More democratic", "Not significant"), 
       col = c(viridis(3)[1], viridis(3)[2], "grey"), 
       pch = 19,
       bty = "n")

dev.off()


#-------------------------------------------------------------------------------
# Coefficient plot - Between
#-------------------------------------------------------------------------------
coefs_low <- as.data.frame(summary(m9_dem_low)$coefficients[6:9,])
coefs_high <- as.data.frame(summary(m9_dem_high)$coefficients[6:9,])

# Create data frames for each model
coefs_low$CI_low <- coefs_low[,"Estimate"] - qnorm(0.95)*coefs_low[,"Std. Error"]
coefs_low$CI_high <- coefs_low[,"Estimate"] + qnorm(0.95)*coefs_low[,"Std. Error"]

coefs_high$CI_low <- coefs_high[,"Estimate"] - qnorm(0.95)*coefs_high[,"Std. Error"]
coefs_high$CI_high <- coefs_high[,"Estimate"] + qnorm(0.95)*coefs_high[,"Std. Error"]


pdf("Plots/Coefficients_table2_between.pdf", width = 7.5)

par(mar = c(5.1, 9, 2.5, 2.1)) # c(bottom, left, top, right))

plot(1,
     type = "n",
     ylim = c(0,2.5),
     bty = "n",
     xlab = "Between coefficients and 95% confidence intervals",
     xlim = c(-1, 1.75),
     ylab = "",
     yaxt = "n",
     cex.lab = 1.1)


# add grid
segments(x0 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5), y0 = 0,
         x1 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5), y1 = 2.5,
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

segments(x0 = -1.5, y0 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         x1 = 1.5, y1 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

# add null line
segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2.5,
         lty = "solid", lwd = 2, col = "black")


# add point estimates
points(x = coefs_low$Estimate,
       y = rev(c(0.25, 0.75, 1.5, 2.25)),
       pch = 16,
       col = c("grey", viridis(3)[1], "grey", viridis(3)[1]),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         y1 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         col = c("grey", viridis(3, alpha = 0.4)[1], "grey", viridis(3, alpha = 0.4)[1]),
         x0 = coefs_low$CI_low,
         x1 = coefs_low$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add point estimates
points(x = coefs_high$Estimate,
       y = rev(c(0.15, 0.65, 1.4, 2.15)),
       pch = 16,
       col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], "grey"),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         y1 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         col = c(viridis(3, alpha = 0.4)[2], viridis(3, alpha = 0.4)[2], viridis(3, alpha = 0.4)[2], "grey"),
         x0 = coefs_high$CI_low,
         x1 = coefs_high$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add coefficients text
text(x = -1.95,
     y = rev(c(0.25, 0.75, 1.5, 2.25)),
     labels = c("Pollution outsourcing", "Population", "GDP per capita", "GDP per capita squ."),
     xpd = T,
     cex = 0.9,
     pos = 4)

# Add a legend
legend("topright", 
       legend = c("Less democratic", "More democratic", "Not significant"), 
       col = c(viridis(3)[1], viridis(3)[2], "grey"), 
       pch = 19,
       bty = "n")

dev.off()


```



# Quantities of interest

## Simulated interaction & marginal effects

```{r plots simulated interaction effect}

#-------------------------------------------------------------------------------
# Simulate interaction effect 
#-------------------------------------------------------------------------------
nsim <- 1000
beta_hat <- coef(m8_out_dem_int_c)
V_hat <- vcov(m8_out_dem_int_c)
S <- mvrnorm(nsim, beta_hat, V_hat)
quants_S <- apply(S, 2, quantile, probs = c(0.025, 0.5, 0.975))

## Plot interaction term
pdf("plots/sim_interact_outsource_dem.pdf")

plot(density(S[,"log_cc_outs:vdem_polyarchy"]),
     las = 1,
     lwd = 3,
     col = viridis(4)[1],
     bty = "n",
     cex = 1.1,
     cex.lab = 1.3,
     yaxt = "n",
     ylab = "Density",
     main = "Democracy x Pollution Outsourcing",
     xlab = "Simulated Interaction Effect")

abline(v = c(quants_S[c(1,3), "log_cc_outs:vdem_polyarchy"]), lty = 2, col = viridis(3)[2])
abline(v = c(quants_S[2,"log_cc_outs:vdem_polyarchy"]), lty = 1, lwd = 1.5, col = viridis(3)[2])
abline(v = 0, lty = 1, lwd = 1, col = "black")

legend("topleft",
       lty = c("solid", "dashed"),
       col = c(viridis(3)[2], viridis(3)[2]),
       legend = c("Mean", "95% CIs"),
       bty = "n")

dev.off()


#-------------------------------------------------------------------------------
# Simulate marginal effects 
#-------------------------------------------------------------------------------

# library(marginaleffects)
# library(ggExtra)
# library(cowplot)
# 
# base_plot <-
#   plot_cme(m8_out_dem_int_c,
#          variables = "log_cc_outs",
#          condition = "vdem_polyarchy",
#          conf_level = 0.95) +
# ggtitle("Marginal Effect at the Mean of Pollution Outsourcing") +
# theme_bw() +
# theme(panel.border = element_blank(),
#       axis.title.x = element_text(size = 15),
#       axis.title.y = element_text(size = 15),
#       axis.text = element_text(size = 13),
#       plot.title = element_text(size = 17, face = "bold", hjust = 0.5)) +
# geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
# xlab("Democracy") +
# ylab("Marginal Effect of Pollution Outsourcing")
# 
# # Create the histogram plot for the x-axis variable
# hist_plot <- ggplot(data_s, aes(x = vdem_polyarchy)) +
#   geom_histogram(bins = 30, fill = viridis(1, alpha = 0.25), color = viridis(1, alpha = 0.75)) +
#   theme_void()
# 
# # Combine the base plot and histogram plot using cowplot
# combined_plot <- ggdraw() +
#   draw_plot(base_plot, x = 0, y = 0, width = 1, height = 0.8) +
#   draw_plot(hist_plot, x = 0.09, y = 0.07, width = 0.9, height = 0.2)
# 
# # Print the combined plot
# pdf("plots/Marginal_outsource_dem_1.pdf")
# par(mar = c(2.5, 2.4,0, 2.1)) # c(bottom, left, top, right))
# combined_plot
# dev.off()


pdf("plots/Marginal_outsource_dem_2.pdf")

interplot(m6_out_dem_int,
          var1 = "log_cc_outs",
          var2 = "vdem_polyarchy",
          hist = T,
          ci = 0.95,
          sims = 1000,
          ercolor = viridis(1, alpha = 0.75),
          rfill = viridis(1, alpha = 0.05),
          ralpha = 0.25) +
  xlab("Democracy") +
  ylab("Marginal Effect") +
  ggtitle("Marginal Effect at the Mean of Pollution Outsourcing") +
  theme_bw() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  theme(axis.line = element_line(colour = "black"),
        axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text = element_text(size = 13),
        plot.title = element_text(size = 17, hjust = 0.5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

dev.off()


## Alternatively
library(margins)
library(broom)
library(ggExtra)

meff <- margins(m6_out_dem_int, variables = "log_cc_outs", at = list(vdem_polyarchy = seq(0.016, 0.926, length.out = 30)))
meff_df <- as.data.frame(summary(meff))

p <- ggplot(meff_df, aes(x = vdem_polyarchy, y = AME)) +
  geom_line() +
  geom_ribbon(aes(ymin = AME - 1.96 * SE, ymax = AME + 1.96 * SE), alpha = 0.2) +
  labs(x = "Democracy (vdem_polyarchy)", y = "Marginal Effect of Pollution Outsourcing", 
       title = "Marginal Effect of Pollution Outsourcing on Pollution") +
  theme_minimal()

# Add the marginal histogram
p_with_hist <- ggMarginal(p, type = "histogram", margins = "x", size = 5, bins = 30, fill = "blue", alpha = 0.5)

print(p)

```

## Simulate expected values and first differences: Model group 1 (Within)

```{r expected values 1, within}

#-------------------------------------------------------------------------------
# Get X for observed value approach
#-------------------------------------------------------------------------------
extract_ccode <- m3_outsource_c$model$`as.factor(ccode)` ## extract included countries
extract_year <- m3_outsource_c$model$`as.factor(year)`   ## extract included years

## Create dummy variables for countries and years
data_ova <- dummy_cols(data_s[which(data_s$ccode %in% extract_ccode &  
                                    data_s$year %in% extract_year),],
                       select_columns = c("ccode", "year"))



## Reduce to correct length
data_ova <- data_ova[which(!is.na(data_ova$vdem_polyarchy) &
                           !is.na(data_ova$log_cc_outs) &
                           !is.na(data_ova$log_pop) &
                           !is.na(data_ova$log_gdp_pc)),]

## make sure to select correct columns for the dummies
first_year <- which(colnames(data_ova) == "year_1991")
last_year <- which(colnames(data_ova) == "year_2015")
first_ccode <- which(colnames(data_ova) == "ccode_8")
last_ccode <- which(colnames(data_ova) == "ccode_894")

## Get X
X <- as.matrix(cbind(1,
                     data_ova$vdem_polyarchy, 
                     data_ova$log_pop,
                     data_ova$log_gdp_pc,
                     data_ova$log_gdp_pc_sq,
                     data_ova[,c(first_year:last_year)],
                     data_ova[,c(first_ccode:last_ccode)]))

## Check dimensions
X <- na.omit(X)
dim(X)

## Get colnames
colnames(X) <- names(coef(m3_outsource_c))

#-------------------------------------------------------------------------------
# Install simulation github Rittmann et al. (2023)
#-------------------------------------------------------------------------------
install_github("mneunhoe/simloglm")
library (simloglm)

## Function to sample from inverse gamma distribution
rinvgamma <- function(n, shape, rate = 1, scale = 1/rate){
  if(missing(rate) && !missing(scale))
    rate <- 1/scale
  1/stats::rgamma(n, shape, rate)
}

## Set up informal posterior of coefficients
nsim <- 1000 # number of draws
beta_hat <- coef(m3_outsource_c)
sigma_hat <- summary(m3_outsource_c)$sigma
X_prime_X <- summary(m3_outsource_c)$cov.unscaled

## First sigma^2
set.seed(199610)
sigma2_tilde <- rinvgamma(nsim,
                          shape = m3_outsource_c$df.residual/2,
                          rate = (sigma_hat^2*m3_outsource_c$df.residual)/2)

# Now the betas
beta_tilde <- matrix(NA,
                     nrow = nsim,
                     ncol = length(beta_hat))

for(sim in 1:nsim){
  beta_tilde[sim, ] <-
    MASS::mvrnorm(1, beta_hat, X_prime_X * sigma2_tilde[sim])
}


#-------------------------------------------------------------------------------
# Set scenarios: over range of democracy
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Determine "reasonable" variation of democracy variable
range_dem <- aggregate(data_ova$vdem_polyarchy,
                       by = list(data_ova$cname),
                       FUN = range)

names(range_dem) <- c("country", "range")

# get the difference
range_dem$diff <- range_dem$range[,2]- range_dem$range[,1]

# get the respective country
max_range_dem_country <- range_dem$country[which.max(range_dem$diff)]

# and the respective values (min and max > used for setting the scenario)
min_dem <- range_dem$range[,1][which.max(range_dem$diff)]
max_dem <- range_dem$range[,2][which.max(range_dem$diff)]

range_dem <- as.vector(seq(min_dem, max_dem, length.out = 30))


# Create empty matrix to store the scenarios
cases <- array(NA, 
               c(dim(X), length(range_dem)))

# Copy in our X
cases[,,] <- X # because OVA not Average case!

# Select: Democracy over range
select <- which(colnames(X) == "vdem_polyarchy")

for(i in 1:length(range_dem)){
  cases[ ,select, i] <- range_dem[i]
}

head(cases)
dim(cases) 

# check dimensions 
# 3933 rows/datapoints
# 190 variables (incl. country and year dummies)
# 30 scenarios

# Calculate linear predictor on log scale & retransform
E_Y_c_dem <- matrix(NA, nrow = nsim, ncol = length(range_dem)) # empty matrix for storage

for(i in 1:length(range_dem)){              # 30 rounds (for range of dem variable)
  ev <- beta_tilde %*% t(cases[,,i])        # calculate linear predictor on log scale
  ev_plus_gamma <- ev + 1/2*sigma2_tilde    # add draws of 1/2*sigma2_tilde
  ev_transf <- exp(ev_plus_gamma)           # transform
  ev_transf_m <- ev_transf #- 1              # E(y) - 1
  tmp_val <- apply(ev_transf_m, 1, mean)    # now average results
  E_Y_c_dem[,i] <- tmp_val                  # store in val object
}

# Summarize to get CIs
CI_E_Y_c_dem <- apply(E_Y_c_dem, 2, quantile, c(0.025, 0.975))

# Now get the point estimates 
E_Y_c_hat_dem <- matrix(NA, nrow = length(range_dem), ncol = 1)

for(i in 1:length(range_dem)){                         # 30 rounds (for range of dem variable)
  ev_point <- beta_hat %*% t(cases[,,i])               # use beta_hat (not simulated)
  ev_point_plus_gamma <- ev_point + 1/2*sigma_hat^2    # use sigma_hat (not simulated)
  ev_point_transf <- exp(ev_point_plus_gamma)          # transform
  ev_point_transf_m <- ev_point_transf #- 1             # E(y) - 1
  tmp_val_point <- apply(ev_point_transf_m, 1, mean)   # now average results
  E_Y_c_hat_dem[i,] <- tmp_val_point                   # store in val object
}


#-------------------------------------------------------------------------------
# Plot: Expected values of pollution outsourcing (on original scale)
#-------------------------------------------------------------------------------

pdf("plots/Expected value_dem.pdf") 

par(mar = c(5.1, 4.7, 4.1, 2.1)) # c(bottom, left, top, right))

plot(range_dem,
     E_Y_c_hat_dem,
     type = "n",
     ylim = c(59, 75),
     xlim = c(min_dem, max_dem),
     ylab = expression("Pollution Outsourcing [Gg]"),
     xlab = "Democracy",
     bty = "n",
     main = NULL,
     cex.lab = 1.3)

segments(x0 = range_dem, x1 = range_dem,
         y1 = CI_E_Y_c_dem[2,], y0 = CI_E_Y_c_dem[1,],
         col = viridis(1, 0.25),
         lwd = 4, lend = 1)

points(range_dem, E_Y_c_hat_dem, col = viridis(1, 0.8), pch = 20,
       cex = 1.5)


# Add a "histogram" of actual X1-values.
axis(1,
     at = data_ova$vdem_polyarchy,
     col.ticks = "gray30",
     labels = FALSE,
     tck = 0.02)

dev.off()


#-------------------------------------------------------------------------------
# First difference
#-------------------------------------------------------------------------------

## First difference: Democracy high - low
FD_dem_hat <- E_Y_c_hat_dem[30,] - E_Y_c_hat_dem[1,]  ## max - min
FD_dem <- E_Y_c_dem[,30] - E_Y_c_dem[,1] 
CI_FD_dem <- quantile(FD_dem, c(0.025, 0.975))


#-------------------------------------------------------------------------------
## How "big" is the difference compared to variation in the dataset?
#-------------------------------------------------------------------------------
sd_outs <- aggregate(data_ova$cf_cc_pop_mean_outs,
                     by = list(data_ova$cname),
                     FUN = sd)

mean_within_country_sd <- mean(sd_outs[,2], na.rm = T)
share_FD_var <- FD_dem_hat / mean_within_country_sd

```

## Simulate expected values and first differences: Model group 1 (Between)

```{r expected values 1, between}

#-------------------------------------------------------------------------------
# Start with set-up for retransformation
#-------------------------------------------------------------------------------
fixef(m3_wb)
ranef(m3_wb)

# Set up informal posterior of coefficients
nsim <- 1000 # number of draws

beta_hat_b <- c()

for(i in 1:length(fixef(m3_wb))){
  beta_hat_b[i] <- c(fixef(m3_wb)[[i]])
}

sigma_hat_b <- summary(m3_wb)$sigma
X_prime_X_b <- as.matrix(vcov(m3_wb)) / summary(m3_wb)$sigma^2 ## equivalent to vcov$unscaled

# First sigma^2
set.seed(199610)
sigma2_tilde_b <- rinvgamma(nsim,
                            shape = df.residual(m3_wb)/2,
                            rate = (sigma_hat_b^2*df.residual(m3_wb))/2)

# Now the betas
beta_tilde_b <- matrix(NA,
                       nrow = nsim,
                       ncol = length(beta_hat_b))

for(sim in 1:nsim){
  beta_tilde_b[sim, ] <-
    MASS::mvrnorm(1, beta_hat_b, X_prime_X_b * sigma2_tilde_b[sim])
}

# Set scenarios
scen_1_min_b <- cbind(1,
                      mean(data_ova$demeaned_vdem_poly, na.rm = T),
                      mean(data_ova$demeaned_log_gdp_pc, na.rm = T),
                      mean(data_ova$demeaned_log_gdp_pc_sq, na.rm = T),
                      mean(data_ova$demeaned_log_pop, na.rm = T),
                      min(data_ova$mean_vdem_poly, na.rm = T),
                      mean(data_ova$mean_log_gdp_pc, na.rm = T),
                      mean(data_ova$mean_log_gdp_pc_sq, na.rm = T),
                      mean(data_ova$mean_log_pop, na.rm = T),
                      median(data_ova$year_1991, na.rm = T),
                      median(data_ova$year_1992, na.rm = T),
                      median(data_ova$year_1993, na.rm = T),
                      median(data_ova$year_1994, na.rm = T),
                      median(data_ova$year_1995, na.rm = T),
                      median(data_ova$year_1996, na.rm = T),
                      median(data_ova$year_1997, na.rm = T),
                      median(data_ova$year_1998, na.rm = T),
                      median(data_ova$year_1999, na.rm = T),
                      median(data_ova$year_2000, na.rm = T),
                      median(data_ova$year_2001, na.rm = T),
                      median(data_ova$year_2002, na.rm = T),
                      median(data_ova$year_2003, na.rm = T),
                      median(data_ova$year_2004, na.rm = T),
                      median(data_ova$year_2005, na.rm = T),
                      median(data_ova$year_2006, na.rm = T),
                      median(data_ova$year_2007, na.rm = T),
                      median(data_ova$year_2008, na.rm = T),
                      median(data_ova$year_2009, na.rm = T),
                      median(data_ova$year_2010, na.rm = T),
                      median(data_ova$year_2011, na.rm = T),
                      median(data_ova$year_2012, na.rm = T),
                      median(data_ova$year_2013, na.rm = T),
                      median(data_ova$year_2014, na.rm = T),
                      median(data_ova$year_2015, na.rm = T)
                      )

# colnames
colnames(scen_1_min_b) <- names(fixef(m3_wb))

# copy existing scenario1 into new object scenario2 
scen_1_max_b <- scen_1_min_b

# switch only the changing values to get scenario with max inequ
scen_1_max_b[, which(colnames(scen_1_max_b) == "mean_vdem_poly")] <- max(data_ova$mean_vdem_poly, na.rm = T)


#-------------------------------------------------------------------------------
# Sample-specific means (understandable scenario)
#-------------------------------------------------------------------------------
# min(data_scen$mean_inequ)                   ## 0.29
# max(data_scen$mean_inequ)                   ## 0.68
# unique(data_scen$country[which(data_scen$mean_inequ == min(data_scen$mean_inequ))]) ## Netherlands
# unique(data_scen$country[which(data_scen$mean_inequ == max(data_scen$mean_inequ))]) ## Namibia
# mean(exp(data_scen$mean_income))            ## 13 326
# mean(data_scen$mean_winning)                ## 0.71
# mean(data_scen$mean_trade)                  ## 0.84
# mean(data_scen$mean_cpi)                    ## 4.31
# mean(data_scen$mean_industrial, na.rm = T)  ## 0.28
# mean(exp(data_scen$mean_pop))               ## 184

X_c_b <- rbind(scen_1_max_b, scen_1_min_b)

# Calculate the linear predictor on log scale
X_beta_b <- beta_tilde_b %*% t(X_c_b)

# Now transform back to original scale

# First add draws of 1/2*sigma2_tilde to each column
X_beta_sigma_tilde_b <- apply(X_beta_b, 2, function(x) x + 1/2*sigma2_tilde_b)

# Transform
E_Y_c_b <- exp(X_beta_sigma_tilde_b)

# Summarize to get CIs
CI_E_Y_c_b <- apply(E_Y_c_b, 2, quantile, c(0.025, 0.975))

# Use beta_hat and sigma_hat for point estimates
X_beta_hat_b <- beta_hat_b %*% t(X_c_b)
X_beta_sigma_hat_b <- X_beta_hat_b + 1/2*sigma_hat_b^2

# Point estimate
E_Y_c_hat_b <- exp(X_beta_sigma_hat_b)

# First difference
FD_max_min_hat_b <- E_Y_c_hat_b[,1] - E_Y_c_hat_b[,2]
FD_max_min_b <- E_Y_c_b[,1] - E_Y_c_b[,2]
CI_FD_max_min_b <- quantile(FD_max_min_b, c(0.025, 0.975))

summary(data_s$cf_cc_pop_mean_outs)

#-------------------------------------------------------------------------------
# How "big" is the first difference compared to the SD of the DV?
#-------------------------------------------------------------------------------
mean_pm25_bc <- aggregate(data_ova$PM25_pop_weighed,
                          by = list(data_scen$country),
                          FUN = mean, na.rm = T)

colnames(mean_pm25_bc)[1:2] <- c("country", "mean")
sd_pm25_b <- sd(mean_pm25_bc$mean)
share_fd_sd_b <- FD_max_min_hat_b/sd_pm25_b


#-------------------------------------------------------------------------------
# Plot
#-------------------------------------------------------------------------------

pdf("Plots/EV_max_min_between.pdf")

# First plot: EV density
plot(density(E_Y_c_b[,1]),
     bty = "n",
     xlim = c(0,41),
     main = NA,
     las = 1,
     ylim = c(0,0.2),
     yaxt = "n",
     cex = 1.1,
     cex.lab = 1.3,
     xlab = "Outsourcing [Gigagrams]",
     type = "n")

polygon(density(E_Y_c_b[,1]),
        col = viridis(3, alpha = 0.4)[1],
        border = F,
        main = NULL)

polygon(density(E_Y_c_b[,2]),
        col = viridis(3, alpha = 0.4)[2],
        border = F,
        main = NULL)

lines(density(E_Y_c_b[,1]),
      col = viridis(3)[1])

lines(density(E_Y_c_b[,2]),
      col = viridis(3)[2])

abline(v = c(E_Y_c_hat_b[,1],
             E_Y_c_hat_b[,2]),
       lty = 2, lwd = 2,
       col = c(viridis(3)[1],
               viridis(3)[2]))

legend("topright",
       legend = c("Max. Democracy",
                  "Min. Democracy"),
       col = c(viridis(3, alpha = 0.5)[1],
               viridis(3, alpha = 0.5)[2]),
       pch = 19,
       cex = 1.1,
       bty = "n")

dev.off()


# Second plot: First difference
pdf("Plots/FD_max_min_between.pdf")

plot(y = 1,
     x = FD_max_min_hat_b,
     col = "darkgrey",
     ylim = c(0,2),
     xlim = c(-5.5,11),
     xlab = "",
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1, x0 = CI_FD_max_min_b[1],
         y1 = 1, x1 = CI_FD_max_min_b[2],
         col = adjustcolor("darkgrey", alpha = 0.4),
         lwd = 12, cex = 1.5, lend = 1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2,
         lty = "dashed", lwd = 2)

text(x = FD_max_min_hat_b+0.5,
     y = 0.8,
     labels = c("First Difference"),
     cex = 1.3)

text(x = FD_max_min_hat_b+0.5,
     y = 0.65,
     labels = c("(Max - Min)"),
     cex = 0.9)

dev.off()

```

## Simulate expected values and first differences: Model group 2

```{r expected values 2}

#-------------------------------------------------------------------------------
# Get X for observed value approach
#-------------------------------------------------------------------------------
extract_ccode2 <- m8_out_dem_int_c$model$`as.factor(ccode)` ## extract included countries
extract_year2 <- m8_out_dem_int_c$model$`as.factor(year)`   ## extract included years

## Create dummy variables for countries and years
data_ova2 <- dummy_cols(data_s[which(data_s$ccode %in% extract_ccode2 &  
                                     data_s$year %in% extract_year2),],
                        select_columns = c("ccode", "year"))



## Reduce to correct length
data_ova2 <- data_ova2[which(!is.na(data_ova2$vdem_polyarchy) &
                             !is.na(data_ova2$log_cc_outs) &
                             !is.na(data_ova2$log_pop) &
                             !is.na(data_ova2$log_gdp_pc) &
                             !is.na(data_ova2$log_pm25_pop)),]

## make sure to select correct columns for the dummies
first_year2 <- which(colnames(data_ova2) == "year_1999")
last_year2 <- which(colnames(data_ova2) == "year_2015")
first_ccode2 <- which(colnames(data_ova2) == "ccode_8")
last_ccode2 <- which(colnames(data_ova2) == "ccode_894")

## Get X
X2 <- as.matrix(cbind(1,
                      data_ova2$log_cc_outs,
                      data_ova2$vdem_polyarchy, 
                      data_ova2$log_pop,
                      data_ova2$log_gdp_pc,
                      data_ova2$log_gdp_pc_sq,
                      data_ova2[,c(first_year2:last_year2)],
                      data_ova2[,c(first_ccode2:last_ccode2)],
                      data_ova2$log_cc_outs * data_ova2$vdem_polyarchy))

## Check dimensions
X2 <- na.omit(X2)
dim(X2)

## Get colnames
colnames(X2) <- names(coef(m8_out_dem_int_c))

#-------------------------------------------------------------------------------
# Follow Rittmann et al.'s instructions
#-------------------------------------------------------------------------------

## Set up informal posterior of coefficients
beta_hat2 <- coef(m8_out_dem_int_c)
sigma_hat2 <- summary(m8_out_dem_int_c)$sigma
X_prime_X2 <- summary(m8_out_dem_int_c)$cov.unscaled

## First sigma^2
set.seed(199610)
sigma2_tilde2 <- rinvgamma(nsim,
                           shape = m8_out_dem_int_c$df.residual/2,
                           rate = (sigma_hat2^2*m8_out_dem_int_c$df.residual)/2)

# Now the betas
beta_tilde2 <- matrix(NA,
                      nrow = nsim,
                      ncol = length(beta_hat2))

for(sim in 1:nsim){
  beta_tilde2[sim, ] <-
    MASS::mvrnorm(1, beta_hat2, X_prime_X2 * sigma2_tilde2[sim])
}


#-------------------------------------------------------------------------------
# Determine "reasonable" variation of outsourcing
range_outsource <- aggregate(data_ova2$log_cc_outs,
                             by = list(data_ova2$cname),
                             FUN = range)

names(range_outsource) <- c("country", "range")

# get the difference
range_outsource$diff <- range_outsource$range[,2]-range_outsource$range[,1]

# get the respective country
max_range_outsource_country <- range_outsource$country[which.max(range_outsource$diff)]

# and the respective values (min and max > used for setting the scenario)
min_outsource <- range_outsource$range[,1][which.max(range_outsource$diff)]
max_outsource <- range_outsource$range[,2][which.max(range_outsource$diff)]


#-------------------------------------------------------------------------------
# Determine "reasonable" variation of dem
range_dem2 <- aggregate(data_ova2$vdem_polyarchy,
                        by = list(data_ova2$cname),
                        FUN = range)

names(range_dem2) <- c("country", "range")

# get the difference
range_dem2$diff <- range_dem2$range[,2]- range_dem2$range[,1]

# get the respective country
max_range_dem_country2 <- range_dem2$country[which.max(range_dem2$diff)]

# and the respective values (min and max > used for setting the scenario)
min_dem2 <- range_dem2$range[,1][which.max(range_dem2$diff)]
max_dem2 <- range_dem2$range[,2][which.max(range_dem2$diff)]

range_dem2 <- as.vector(seq(min_dem, max_dem, length.out = 30))



#-------------------------------------------------------------------------------
## Create empty matrix to store the scenarios
cases2 <- array(NA, 
                c(dim(X2), 4))

## Copy in our X
cases2[,,] <- X2 

## Add names
colnames(cases2) <- names(beta_hat2)

## Case 1: min dem & min outsource
cases2[ ,"vdem_polyarchy", 1] <- min_dem2
cases2[ ,"log_cc_outs", 1] <- min_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 1] <- min_dem2*min_outsource

## Case 2: min dem & max outsource
cases2[ ,"vdem_polyarchy", 2] <- min_dem2
cases2[ ,"log_cc_outs", 2] <- max_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 2] <- min_dem2*max_outsource

## Case 3: max dem & min outsource
cases2[ ,"vdem_polyarchy", 3] <- max_dem2
cases2[ ,"log_cc_outs", 3] <- min_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 3] <- max_dem2*min_outsource

## Case 4: max dem & max outsource
cases2[ ,"vdem_polyarchy", 4] <- max_dem2
cases2[ ,"log_cc_outs", 4] <- max_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 4] <- max_dem2*max_outsource


#-------------------------------------------------------------------------------
## Calculate linear predictor on log scale & retransform
#-------------------------------------------------------------------------------
E_Y_c2 <- matrix(NA, nrow = nsim, ncol = 4)  # empty matrix for storage

for(i in 1:4){                              # four rounds (for scenarios)
  ev <- beta_tilde2 %*% t(cases2[,,i])      # calculate linear predictor on log scale
  ev_plus_gamma <- ev + 1/2*sigma2_tilde2   # add draws of 1/2*sigma2_tilde
  ev_transf <- exp(ev_plus_gamma)           # transform
  ev_transf_m <- ev_transf                  # E(y) 
  tmp_val <- apply(ev_transf_m, 1, mean)    # now average results
  E_Y_c2[,i] <- tmp_val                     # store in val object
}

## Summarize to get CIs
CI_E_Y_c2 <- apply(E_Y_c2, 2, quantile, c(0.025, 0.5, 0.975))

## Now get the point estimates 
E_Y_c_hat2 <- matrix(NA, nrow = 4, ncol = 1)

for(i in 1:4){                                       # four rounds (for scenarios)
  ev_point <- beta_hat2 %*% t(cases2[,,i])           # use beta_hat (not simulated)
  ev_point_plus_gamma <- ev_point + 1/2*sigma_hat2^2 # use sigma_hat (not simulated)
  ev_point_transf <- exp(ev_point_plus_gamma)        # transform
  ev_point_transf_m <- ev_point_transf               # E(y)
  tmp_val_point <- apply(ev_point_transf_m, 1, mean) # now average results
  E_Y_c_hat2[i,] <- tmp_val_point                    # store
}


#-------------------------------------------------------------------------------
## First differences
#-------------------------------------------------------------------------------

## First difference: Democracy low -> Outsource max - min
FD_dem_low_hat <- E_Y_c_hat2[2,] - E_Y_c_hat2[1,]  ## max - min
FD_dem_low <- E_Y_c2[,2] - E_Y_c2[,1] 
CI_FD_dem_low <- quantile(FD_dem_low, c(0.025, 0.975))

## First difference: Democracy high -> Outsource max - min
FD_dem_high_hat <- E_Y_c_hat2[4,] - E_Y_c_hat2[3,]  ## max - min
FD_dem_high <- E_Y_c2[,4] - E_Y_c2[,3] 
CI_FD_dem_high <- quantile(FD_dem_high, c(0.025, 0.975))

## First difference of first difference
FD_FD_hat <- FD_dem_high_hat - FD_dem_low_hat
FD_FD <- FD_dem_high - FD_dem_low
CI_FD_FD <- quantile(FD_FD, c(0.025, 0.975))

#-------------------------------------------------------------------------------
## How "big" is the difference compared to variation in the dataset?
#-------------------------------------------------------------------------------
sd_pm25 <- aggregate(data_ova2$populationweightedpm25ugm3,
                     by = list(data_ova2$cname),
                     FUN = sd)

mean_pm25_country_sd <- mean(sd_pm25[,2], na.rm = T)
mean_pm25_sd_between <- sd(data_ova2$populationweightedpm25ugm3)
share_FD_low_var <- FD_dem_low_hat / mean_pm25_country_sd
share_FD_high_var <- abs(FD_dem_high_hat) / mean_pm25_country_sd
share_FD_FD_var <- abs(FD_FD_hat) / mean_pm25_country_sd
share_FD_FD_between <- abs(FD_FD_hat) / mean_pm25_sd_between


#-------------------------------------------------------------------------------
## Plot First differences
#-------------------------------------------------------------------------------
pdf("plots/FDs_dem_high_low.pdf")

plot(y = 1,
     x = FD_dem_low_hat,
     col = viridis(3)[1],
     ylim = c(0,3),
     xlim = c(-2,7),
     xlab = expression("PM"[2.5]*" [micrograms per cubicmeter]"),
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1, x0 = CI_FD_dem_low[1],
         y1 = 1, x1 = CI_FD_dem_low[2],
         col = viridis(3, alpha = 0.4)[1],
         lwd = 12, cex = 1.5, lend = 1)

segments(y0 = 2, x0 = CI_FD_dem_high[1],
         y1 = 2, x1 = CI_FD_dem_high[2],
         col = viridis(3, alpha = 0.4)[1],
         lwd = 12, cex = 1.5, lend = 1)

points(y = 2,
       x = FD_dem_high_hat,
       col = viridis(3)[1],
       xlab = "",
       pch = 19,
       main = NULL, 
       bty = "n",
       ylab = "",
       yaxt = "n",
       cex = 3,
       cex.lab = 1.1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 3,
         lty = "dashed", lwd = 2)

text(x = FD_dem_low_hat,
     y = 0.8,
     labels = c("Non-democratic"),
     cex = 1.1)

text(x = FD_dem_low_hat,
     y = 0.57,
     labels = c("Outsourcing (max - min)"),
     cex = 0.9)

text(x = FD_dem_high_hat-0.35,
     y = 1.8,
     labels = c("Democratic"),
     cex = 1.1)

text(x = FD_dem_high_hat-0.35,
     y = 1.57,
     labels = c("Outsourcing (max - min)"),
     cex = 0.9)

dev.off()

## First difference of first difference
pdf("plots/FD_FD.pdf")

plot(y = 1.5,
     x = FD_FD_hat,
     col = viridis(3)[2],
     ylim = c(0,3),
     xlim = c(-3.5,0.75),
     xlab = expression("PM"[2.5]*" [micrograms per cubicmeter]"),
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1.5, x0 = CI_FD_FD[1],
         y1 = 1.5, x1 = CI_FD_FD[2],
         col = viridis(3, alpha = 0.4)[2],
         lwd = 12, cex = 1.5, lend = 1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 3,
         lty = "dashed", lwd = 2)

text(x = FD_FD_hat,
     y = 1.26,
     labels = c("FD of FD"),
     cex = 1.1)

text(x = FD_FD_hat,
     y = 1.05,
     labels = c("Democracy (high-low)"),
     cex = 0.9)

dev.off()

```



# Robustness

## Temporally lagged DV

```{r lagged DV}

#-------------------------------------------------------------------------------
# Lag DV
#-------------------------------------------------------------------------------
# lag co2
data_non_oecd <- data_non_oecd %>%
  group_by(ccode) %>%
  arrange(year) %>%
  mutate(lag_wdi_co2 = dplyr::lag(wdi_co2))


```

## Replacing DV with ecological footprint data

```{r DV ecolog footprint}

#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_eco <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_eco_int <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy + 
                  export_fdi_index * vdem_polyarchy + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_eco_c <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_eco_int_c <- lm(ef_ef ~ lag_ef_ef + export_fdi_index + vdem_polyarchy + 
                    export_fdi_index * vdem_polyarchy  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_eco, m3_eco_int, m3_eco_c, m3_eco_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(Ecological footprint)",
          covariate.labels = c("ln(Ecological footprint)$_{t-1}$", "Export-FDI index",
                               "Electoral democracy", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Electoral dem.", "Constant"))
``` 

## Replacing DV with changes in CO2

```{r DV CO2 change}

#-------------------------------------------------------------------------------
# Calculate (lagged) change variable
#-------------------------------------------------------------------------------
data_s$co2change <- data_s$lag_wdi_co2 - data_s$wdi_co2

# lag change co2
data_s <- data_s %>%
  group_by(ccode) %>%
  arrange(year) %>%
  mutate(lag_co2change = dplyr::lag(co2change))


#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_co2c <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_co2c_int <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy + 
                  export_fdi_index * vdem_polyarchy + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_co2c_c <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_co2c_int_c <- lm(co2change ~ lag_co2change + export_fdi_index + vdem_polyarchy + 
                    export_fdi_index * vdem_polyarchy  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_co2c, m3_co2c_int, m3_co2c_c, m3_co2c_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "Change ln(CO$_2$ emissions per capita)",
          covariate.labels = c("Change ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Electoral democracy", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Electoral dem.", "Constant"))

``` 

## Replacing Democracy variable: Freedom House & Polity V

```{r IV Freedom House and Polity V}

#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_fh <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_fh_int <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl + 
                  export_fdi_index * fh_cl + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_fh_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_fh_int_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + fh_cl + 
                    export_fdi_index * fh_cl  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_fh, m3_fh_int, m3_fh_c, m3_fh_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(CO$_2$ emissions per capita)",
          covariate.labels = c("ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Dem. (Freedom House)", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Dem. (Freedom House).", "Constant"))


#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_pol <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 + 
              as.factor(year) + as.factor(ccode),
             data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_pol_int <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 + 
                  export_fdi_index * p_polity2 + 
                  as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_pol_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 +
                gdp_pc_log + gdp_pc_log_sq + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_pol_int_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + p_polity2 + 
                    export_fdi_index * p_polity2  +
                    gdp_pc_log + gdp_pc_log_sq + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_pol, m3_pol_int, m3_pol_c, m3_pol_int_c),
          omit = c("ccode", "year"), type = "latex",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(CO$_2$ emissions per capita)",
          covariate.labels = c("ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Dem. (Polity V)", "ln(GDP per capita)", "ln(GDP per capita)$^2$",
                               "ln(Pop. size)", "Export-FDI index x Dem. (Polity V).", "Constant"))

summary(data$fh)
``` 

## Additional controls: Political globaliz. & env. treaties

```{r additional controls}

#-------------------------------------------------------------------------------
# Base models
#-------------------------------------------------------------------------------
m3_add_int <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy +
                   as.factor(year) + as.factor(ccode),
                 data = data_s)

#-------------------------------------------------------------------------------
# Base model + controls
#-------------------------------------------------------------------------------
m3_add_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy +
                env_treaties + dr_pg + gdp_pc_log + pop_log +
                as.factor(year) + as.factor(ccode),
               data = data_s)

#-------------------------------------------------------------------------------
# Base model + interaction + controls
#-------------------------------------------------------------------------------
m3_add_int_c <- lm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                    export_fdi_index * vdem_polyarchy  +
                    env_treaties + dr_pg + gdp_pc_log + pop_log +
                    as.factor(year) + as.factor(ccode),
                   data = data_s)

## Output
stargazer(list(m3_add_int, m3_add_c, m3_add_int_c),
          omit = c("ccode", "year"), type = "text",
          model.numbers = T,
          font.size = "scriptsize",
          digits = 2,
          header = F,
          omit.stat = c("f"),
          dep.var.labels = "ln(CO$_2$ emissions per capita)",
          covariate.labels = c("ln(CO$_2$ emissions per capita)$_{t-1}$", "Export-FDI index",
                               "Electoral democracy", "Environm. treaties", "Political globaliz.", 
                               "ln(GDP per cap.)", "ln(Pop. size)",
                               "Export-FDI index x Electoral dem.", "Constant"))

``` 

## No lagged DV

```{r no lagged DV}

#-------------------------------------------------------------------------------
# Base model + interaction
#-------------------------------------------------------------------------------
m3_ind_int_no_lag <- lm(log_wdi_co2 ~ export_fdi_index + vdem_polyarchy + 
                         export_fdi_index * vdem_polyarchy + 
                         as.factor(year) + as.factor(ccode),
                       data = data_s)

stargazer(m3_ind_int_no_lag, type = "text", omit = c("ccode", "year"))

```

## Checking autocorrelation and panel-corrected SEs

```{r autocorr}

#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------

## Set up panel data
panel_data <- pdata.frame(data_s, index = c("ccode", "year"))

m3_int_auto <- plm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                     export_fdi_index * vdem_polyarchy,
                    data = panel_data, model = "within", effect = "twoways")

#-------------------------------------------------------------------------------
# Look at summary
#-------------------------------------------------------------------------------
summary(m3_int_auto)

#-------------------------------------------------------------------------------
# Use Breusch-Godfrey test for serial correlation
#-------------------------------------------------------------------------------
bg_test <- bgtest(m3_int_auto)

``` 

## Generalized methods-of-moments dynamic panel estimator

```{r GMM dynamic panel}

#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------

## Set up panel data
panel_data <- pdata.frame(data_s, index = c("ccode", "year"))

## Estimate fixed effects model with individual and time fixed effects
model_fe <- plm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy, 
                data = panel_data, 
                model = "within", 
                effect = "twoways")

m3_int_gmm <- pgmm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy,
                   data = panel_data, 
                   effect = "twoways",
                   model = "twosteps",
                   exo = c("export_fdi_index", "vdem_polyarchy", "export_fdi_index:vdem_polyarchy"),
                   endo = "lag_log_wdi_co2",
                   instruments = c("export_fdi_index", "vdem_polyarchy", 
                                   "export_fdi_index:vdem_polyarchy", 
                                   "year_fe", "country_fe"),
                   gmm.kernel = "two-step")

``` 

## Random effects model

```{r random}

#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------
model_re <- plm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy, 
                data = panel_data, 
                model = "random",
                effect = "individual")

summary(model_re)
```

