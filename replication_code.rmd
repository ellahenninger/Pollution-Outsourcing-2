---
title: "Pollution Outsourcing and Democracy 2"
author: "Ella Henninger"
date: "2023-07-25"
output:
  word_document: default
  html_document: default
---

# Contents of the replication packet

This R-Markdown file replicates all analyses and figures included in the paper "What Makes Democracies Greener? The Role of Pollution Offshoring" by Tobias BÃ¶hmelt, Ella Henninger, and Thomas Bernauer.

## Data
 - **Outsourcing data**: Presberger and Bernauer (2023), https://www.sciencedirect.com/science/article/pii/S0959378023000031?via%3Dihub
 - **Pollution data**: Van Donkelaar et al. (2021), https://pubs.acs.org/doi/full/10.1021/acs.est.1c05309
 - **Main data**: Quality of Governance database (QoG), https://www.gu.se/en/quality-government/qog-data
 - **Economic data**: World Development Indicators (2023), https://databank.worldbank.org/source/world-development-indicators#
 - **Democracy data**: V-Dem (2023), https://www.v-dem.net/data/the-v-dem-dataset/


**The code is structured as follows**:

1. Set up

2. Preparatory steps
2.1 Load data
2.2 Create lagged and logged variables

3. Descriptives
3.1 Table summary statistics
3.2 Correlations

4. Analyses
4.1 Models democracy and pollution outsourcing
4.2 Models pollution outsourcing and environmental performance
4.3 Plots model group 1
4.4 Plots model group 2

5. Quantities of interest
5.1 Simulated interaction term and marginal effects
5.2 Expected values outsourcing & first difference: Model group 1
5.3 Expected values & first differences PM2.5: Model group 2

6. Robustness checks
6.1 Replacing DV with ecological footprint data
6.2 Replacing DV with change in CO2
6.3 Replacing democracy variable with Freedom House and Polity V
6.4 Including additional controls: Political globaliz. & Environm. treaties
6.5 Restricting data to FDI inflow >= 0
6.6 Excluding lagged DV
6.7 Checking for autocorrelation and panel-corrected SEs
6.8 GGM dynamic panel estimator
6.9 Random effects model
6.10 Random subsamples

**As a note**: You may be asked to update some packages, please press "yes" to make sure the file runs smoothly.


# Set up

```{r setup, include=FALSE}

## clean environment
rm(list = ls())

# Define which packages needed for analyses
p_needed <-
  c("knitr",
    "dplyr", 
    "psych",
    "stargazer",
    "ggplot2",
    "viridis",
    "haven",
    "MASS",
    "modelsummary",
    "WDI",
    "plm",
    "lmtest",
    "ggmap",
    "maps",
    "tidyr",
    "devtools",
    "data.table",
    "sjPlot",
    "interplot",
    "fastDummies",
    "texreg")

# Check which packages are already installed on your computer
packages <- rownames(installed.packages())

# Check which packages are not installed
p_to_install <- p_needed[!(p_needed %in% packages)]

if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_needed, require, character.only = TRUE)


# Set an option for the final document that can be produced from the .Rmd file.
knitr::opts_chunk$set(echo = TRUE)

## For replicability: session information 
session_info <- print(sessionInfo())

```



# Preparatory steps

## Load data

```{r load data}

#-------------------------------------------------------------------------------
# Data
#-------------------------------------------------------------------------------
data <- read_dta("data/QoG/qog_std_ts_jan23_stata14.dta")

#-------------------------------------------------------------------------------
# Filter data
#-------------------------------------------------------------------------------
data <- data[which(data$year >= 1989),]
data <- data[which(data$year <= 2022),]

```

## Create lagged and logged variables 

```{r variable selection}

#-------------------------------------------------------------------------------
# Create logs
#-------------------------------------------------------------------------------
data$insourced_GHG <- data$cf_cc_pop_mean
data$log_wdi_co2 <- log(1 + data$wdi_co2)  ## plus 1 to avoid negative numbers

## outsourced CO2
data$log_cc_outs <- log(data$cf_cc_pop_mean_outs)
data$log_cc_sum_outs <- log(data$cf_cc_pop_sum_outs + 1)

## other outsourcing variabes
data$log_lu_outs <- log(data$cf_lu_pop_mean_outs + 1)
data$log_en_outs <- log(data$cf_en_pop_mean_outs)
data$log_mf_outs <- log(data$cf_mf_pop_mean_outs)
data$log_bw_outs <- log(data$cf_bw_pop_mean_outs)

## pm2.5
data$log_pm25_pop <- log(data$populationweightedpm25ugm3)
data$log_pm25_geo <- log(data$geographicmeanpm25ugm3)

## carbon footprint of consumption
data$log_ef_carb <- log(data$ef_carb)

## population
data$log_pop <- log(data$wdi_pop)
data$log_pop_den <- log(data$wdi_popden)

## gdp
data$log_gdp_pc <- log(data$wdi_gdpcapcon2015)
data$log_gdp_pc_sq <- data$log_gdp_pc^2
data$log_gdp <- log(data$wdi_gdppppcon2017)


#-------------------------------------------------------------------------------
# Create environmental treaties variable
#-------------------------------------------------------------------------------
data <- data %>% 
  group_by(ccode) %>% 
  mutate(env_treaties = ifelse(any(!is.na(iea_sum_i)), zoo::na.locf(iea_sum_i), NA))

data$env_treaties <- data$env_treaties/100

#-------------------------------------------------------------------------------
# Transform Freedom House civil liberties variable
#-------------------------------------------------------------------------------
data$fh_cl <- 8 - data$fh_cl

#-------------------------------------------------------------------------------
# Rescale political globalization variable (1-10)
#-------------------------------------------------------------------------------
data$dr_pg <- data$dr_pg/100

#-------------------------------------------------------------------------------
# Subset data to relevant variables
#-------------------------------------------------------------------------------
data_s <- dplyr::select(data, "cname", "ccode", "year", "ccodealp", 
                              "insourced_GHG", "cf_cc_pop_mean", "cf_cc_pop_mean_outs", "cf_cc_pop_sum_outs", "log_cc_outs",
                              "log_cc_sum_outs",
                              "log_lu_outs", "log_mf_outs", "log_bw_outs", "log_en_outs",
                              "log_pm25_pop", "log_pm25_geo", "log_wdi_co2",
                              "populationweightedpm25ugm3", "geographicmeanpm25ugm3",
                              "ef_carb", "log_ef_carb",
                              "vdem_polyarchy", "log_gdp_pc", "log_gdp_pc_sq", "log_gdp",
                              "log_pop", "log_pop_den", "fh_cl", "fh_fog",
                              "cf_bw_pop_mean_outs", "cf_en_pop_mean_outs", "cf_lu_pop_mean_outs", "cf_mf_pop_mean_outs",
                              "dr_pg", "fh_status", "env_treaties",  "wdi_trade",
                              "p_polity2", "vdem_partip", "vdem_delibdem", "wdi_gdpind")

```



# Descriptives

## Table summary statistics

```{r descriptives}

#-------------------------------------------------------------------------------
# Table: Summary statistics
#-------------------------------------------------------------------------------
data_descript <- data_s[which(!is.na(data_s$log_cc_outs) &
                              data_s$log_ef_carb != -Inf),]
# 
# options("modelsummary_format_numeric_latex" = "plain")
# datasummary(formula = (`Pollution Outsourcing` = cf_cc_pop_mean_outs) + (`ln(Pollution Outsourcing)` = log_cc_outs) +
#                       (`PM2.5 (pop. weighted)` = populationweightedpm25ugm3) + (`ln(PM2.5) (pop. weighted)` = log_pm25_pop) +
#                       (`PM2.5 (geo. mean)` = geographicmeanpm25ugm3) +  (`ln(PM2.5) (geo. mean)` = log_pm25_geo) +
#                       (`ln(CO2)` = log_wdi_co2) +  (`ln(Environm. Footprint Consumpt.)` = log_ef_carb) +
#                       (`Democracy` = vdem_polyarchy) + (`ln(GDP)` = log_gdp) +
#                       (`ln(GDP per capita)` = log_gdp_pc) + (`ln(Populat. Size)`= log_pop) +
#                       (`Civil liberties (Freedom House)` = fh_cl) +
#                       (`Democracy (Polity V)` = p_polity2) + (`Political Globaliz.` = dr_pg) +
#                       (`Trade Openness` = wdi_trade) + (`Environm. Treaties` = env_treaties)
#               ~ N + Mean + SD + Min + Median + Max,
#             title = "Summary statistics",
#             data = data_descript,
#             output = "latex")

```

## Correlations

```{r correlations}

#-------------------------------------------------------------------------------
## Correlation heat map
#-------------------------------------------------------------------------------
data_cor <- data_descript[,c("log_cc_outs", "log_pm25_pop", "log_wdi_co2", "log_ef_carb",
                             "vdem_polyarchy", "log_gdp", "log_gdp_pc", "log_pop", 
                             "fh_cl", "p_polity2", "wdi_trade", "env_treaties", "dr_pg", "wdi_gdpind")]

data_cor <- na.omit(data_cor)

cormat <- round(cor(data_cor), 2)
melted_cormat <- melt(cormat)

ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  scale_fill_gradient2(midpoint= 0, 
                       low = viridis(3)[1], 
                       mid = "white",
                       high = viridis(3)[2], 
                       na.value = "grey50", space ="Lab") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  geom_tile()


#-------------------------------------------------------------------------------
## Correlation pm2.5 & outsourcing
#-------------------------------------------------------------------------------
cor(data_cor$log_pm25_pop, data_cor$log_cc_outs) ## -0.30
cor(data_cor$log_pm25_pop, data_cor$log_wdi_co2) ## -0.27
cor(data_cor$log_pm25_pop, data_cor$log_ef_carb) ## -0.35

```

## Trends

```{r trends}

#-------------------------------------------------------------------------------
## Differentiate inequality increasing / decreasing countries over time
#-------------------------------------------------------------------------------

## create lead variable
data_trend <- data_s %>%
  group_by(ccode) %>%
  arrange(year)%>%
  mutate(lead_cc_outs = dplyr::lead(cf_cc_pop_mean_outs),
         lead_pm25 = dplyr::lead(populationweightedpm25ugm3),
         lead_democracy = dplyr::lead(vdem_polyarchy))    

## name columns
data_trend <- data_trend[,c("ccode", "year", "cf_cc_pop_mean_outs", "lead_cc_outs",
                            "populationweightedpm25ugm3", "lead_pm25", "vdem_polyarchy", "lead_democracy")]

## add inequality trend column
data_trend$trend_outsource <- NA
data_trend$trend_pollution <- NA
data_trend$trend_democracy <- NA

## get variable that indicates increase vs. decrease in t+1 compared to t
for(i in 1:nrow(data_trend)){
data_trend$trend_outsource[i] <- ifelse((!is.na(data_trend$lead_cc_outs[i]) & !is.na(data_trend$cf_cc_pop_mean_outs[i])),     # if both top10 and lead top10 not NA
                                         (data_trend$lead_cc_outs[i] - data_trend$cf_cc_pop_mean_outs[i]), NA)                # insert diff between them 

data_trend$trend_pollution[i] <- ifelse((!is.na(data_trend$lead_pm25[i]) & !is.na(data_trend$populationweightedpm25ugm3[i])),     # if both top10 and lead top10 not NA
                                         (data_trend$lead_pm25[i] - data_trend$populationweightedpm25ugm3[i]), NA)                # insert diff between them 

data_trend$trend_democracy[i] <- ifelse((!is.na(data_trend$lead_democracy[i]) & !is.na(data_trend$vdem_polyarchy[i])),     # if both top10 and lead top10 not NA
                                         (data_trend$lead_democracy[i] - data_trend$vdem_polyarchy[i]), NA)                # insert diff between them 
}

## get overall trend (more increasing vs. more decreasing years)
summary_trend_outsource <- data_trend %>%
  group_by(ccode) %>%
  summarize(sum_trend_outsource = ifelse(all(is.na(trend_outsource)), NA, sum(trend_outsource, na.rm = TRUE)),
            var_trend_outsource = ifelse(all(is.na(trend_outsource)), NA, var(trend_outsource, na.rm = TRUE))) 

summary_trend_pollution <- data_trend %>%
  group_by(ccode) %>%
  summarize(sum_trend_pollution = ifelse(all(is.na(trend_pollution)), NA, sum(trend_pollution, na.rm = TRUE)),
            var_trend_pollution = ifelse(all(is.na(trend_pollution)), NA, var(trend_pollution, na.rm = TRUE))) 

summary_trend_democracy <- data_trend %>%
  group_by(ccode) %>%
  summarize(sum_trend_democracy = ifelse(all(is.na(trend_democracy)), NA, sum(trend_democracy, na.rm = TRUE)),
            var_trend_democracy = ifelse(all(is.na(trend_democracy)), NA, var(trend_democracy, na.rm = TRUE))) 


## colnames
colnames(summary_trend_outsource)[1:3] <- c("ccode", "trend_outsource", "var_trend_outsource")
colnames(summary_trend_pollution)[1:3] <- c("ccode", "trend_pollution", "var_trend_pollution")
colnames(summary_trend_democracy)[1:3] <- c("ccode", "trend_democracy", "var_trend_democracy")

## combine
data_s <- left_join(data_s, summary_trend_outsource, by = "ccode")
data_s <- left_join(data_s, summary_trend_pollution, by = "ccode")
data_s <- left_join(data_s, summary_trend_democracy, by = "ccode")


summary(data_s$trend_outsource)
summary(data_s$trend_pollution)
summary(data_s$trend_democracy)
summary(data_s$var_trend_outsource)
summary(data_s$var_trend_pollution)
summary(data_s$var_trend_democracy)

## clean up
remove(data_trend)


#-------------------------------------------------------------------------------
# Plot trend variable
#-------------------------------------------------------------------------------
min_diff <- round(min(data_s$trend_pollution, na.rm = TRUE), digits = 2)
max_diff <- round(max(data_s$trend_pollution, na.rm = TRUE), digits = 2)

pdf("plots/trend_pollution.pdf")

ggplot(data_s[which(!is.na(data_s$trend_pollution)),],
       aes(x = reorder(cname, trend_pollution), y = trend_pollution, fill = trend_pollution >= 0)) +
  theme_minimal() +
  geom_bar(stat = "identity") +
  labs(y = "Change in Pollution", x = "Countries") +

  scale_fill_manual(name = NULL,
                    breaks = c("TRUE", "FALSE"),
                    labels = c("Increase", "Decrease"),
                    values = c(viridis(3)[2], 
                               viridis(3)[1])) +
  
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_text(size = 3),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_text(size = 12),
        legend.position = "bottom", 
        legend.text = element_text(size = 10)) +
  
  # annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
  # annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
  coord_flip()

dev.off()


#-------------------------------------------------------------------------------
# Plot trend variable
#-------------------------------------------------------------------------------
min_diff <- round(min(data_s$trend_outsource, na.rm = TRUE), digits = 2)
max_diff <- round(max(data_s$trend_outsource, na.rm = TRUE), digits = 2)

pdf("plots/trend_outsource.pdf")

ggplot(data_s[which(!is.na(data_s$trend_outsource)),],
       aes(x = reorder(cname, trend_outsource), y = trend_outsource, fill = trend_outsource >= 0)) +
  theme_minimal() +
  geom_bar(stat = "identity") +
  labs(y = "Change in Outsourcing", x = "Countries") +

  scale_fill_manual(name = NULL,
                    breaks = c("TRUE", "FALSE"),
                    labels = c("Increase", "Decrease"),
                    values = c(viridis(3)[2], 
                               viridis(3)[1])) +
  
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_text(size = 3),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_text(size = 12),
        legend.position = "bottom", 
        legend.text = element_text(size = 10)) +
  
  # annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
  # annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
  coord_flip()

dev.off()


#-------------------------------------------------------------------------------
# Plot trend variable
#-------------------------------------------------------------------------------
min_diff <- round(min(data_s$trend_democracy, na.rm = TRUE), digits = 2)
max_diff <- round(max(data_s$trend_democracy, na.rm = TRUE), digits = 2)

pdf("plots/trend_democracy.pdf")

ggplot(data_s[which(!is.na(data_s$trend_democracy)),],
       aes(x = reorder(cname, trend_democracy), y = trend_democracy, fill = trend_democracy >= 0)) +
  theme_minimal() +
  geom_bar(stat = "identity") +
  labs(y = "Change in Democracy", x = "Countries") +

  scale_fill_manual(name = NULL,
                    breaks = c("TRUE", "FALSE"),
                    labels = c("Increase", "Decrease"),
                    values = c(viridis(3)[2], 
                               viridis(3)[1])) +
  
  theme(axis.text.x = element_blank(), 
        axis.text.y = element_text(size = 3),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title = element_text(size = 12),
        legend.position = "bottom", 
        legend.text = element_text(size = 10)) +
  
  # annotate("text", x = 168, y = 3.7, label = "Max (India) \n+0.17", size = 3.2) +
  # annotate("text", x = 10, y = -4, label = "Min (Maldives) \n-0.18", size = 3.2) +
  coord_flip()

dev.off()

```



# Analyses

## Create mean and demeaned variables

```{r variable demeaning}

#-------------------------------------------------------------------------------
# Mean and de-meaning
#-------------------------------------------------------------------------------
data_s <- data_s %>%
  group_by(ccode) %>%
  mutate(
    demeaned_log_co2 = log_wdi_co2 - mean(log_wdi_co2, na.rm = T),
    demeaned_log_pm25 = log_pm25_pop - mean(log_pm25_pop, na.rm = T),
    demeaned_log_cc_outs = log_cc_outs - mean(log_cc_outs, na.rm = T),
    demeaned_log_cc_sum_outs = log_cc_sum_outs - mean(log_cc_sum_outs, na.rm = T),
    demeaned_log_bw_outs = log_bw_outs - mean(log_bw_outs, na.rm = T),
    demeaned_log_en_outs = log_en_outs - mean(log_en_outs, na.rm = T),
    demeaned_log_lu_outs = log_lu_outs - mean(log_lu_outs, na.rm = T),
    demeaned_log_mf_outs = log_mf_outs - mean(log_mf_outs, na.rm = T),
    demeaned_cc_outs  = cf_cc_pop_mean_outs - mean(cf_cc_pop_mean_outs, na.rm = T),
    demeaned_ef_carb = ef_carb - mean(ef_carb, na.rm = T),
    demeaned_env_treat = env_treaties - mean(env_treaties, na.rm = T),
    demeaned_dr_pg = dr_pg - mean(dr_pg, na.rm = T),
    demeaned_trade = wdi_trade - mean(wdi_trade, na.rm = T),
    demeaned_gdp = log_gdp - mean(log_gdp, na.rm = T),
    demeaned_vdem_poly = vdem_polyarchy - mean(vdem_polyarchy, na.rm = T),
    demeaned_fh = fh_cl - mean(fh_cl, na.rm = T),
    demeaned_polity = p_polity2 - mean(p_polity2, na.rm = T),
    demeaned_log_pop = log_pop - mean(log_pop, na.rm = T),
    demeaned_log_gdp_pc = log_gdp_pc - mean(log_gdp_pc, na.rm = T),
    demeaned_log_gdp_pc_sq = log_gdp_pc_sq - mean(log_gdp_pc_sq, na.rm = T),
    mean_log_co2 = mean(log_wdi_co2, na.rm = T),
    mean_log_pm25 = mean(log_pm25_pop, na.rm = T),
    mean_log_cc_outs = mean(log_cc_outs, na.rm = T),
    mean_log_cc_sum_outs = mean(log_cc_sum_outs, na.rm = T),
    mean_log_bw_outs = mean(log_bw_outs, na.rm = T),
    mean_log_en_outs = mean(log_en_outs, na.rm = T),
    mean_log_lu_outs = mean(log_lu_outs, na.rm = T),
    mean_log_mf_outs = mean(log_mf_outs, na.rm = T),
    mean_cc_outs = mean(cf_cc_pop_mean_outs, na.rm = T),
    mean_ef_carb = mean(ef_carb, na.rm = T),
    mean_env_treat = mean(env_treaties, na.rm = T),
    mean_dr_pg = mean(dr_pg, na.rm = T),
    mean_trade = mean(wdi_trade, na.rm = T),
    mean_gdp = mean(log_gdp, na.rm = T),
    mean_vdem_poly = mean(vdem_polyarchy, na.rm = T),
    mean_fh = mean(fh_cl, na.rm = T),
    mean_polity = mean(p_polity2, na.rm = T),
    mean_log_pop = mean(log_pop, na.rm = T),
    mean_log_gdp_pc = mean(log_gdp_pc, na.rm = T),
    mean_log_gdp_pc_sq = mean(log_gdp_pc_sq, na.rm = T),
    interaction = log_cc_outs * vdem_polyarchy,
    interaction_bw = log_bw_outs * vdem_polyarchy,
    interaction_en = log_en_outs * vdem_polyarchy,
    interaction_lu = log_lu_outs * vdem_polyarchy,
    interaction_mf = log_mf_outs * vdem_polyarchy,
    interaction_fh = log_cc_outs * fh_cl,
    interaction_polity = log_cc_outs * p_polity2,
    interaction_cc_sum = log_cc_sum_outs * vdem_polyarchy,
    interaction_demeaned = interaction - mean(interaction, na.rm = T),
    interaction_bw_demeaned = interaction_bw - mean(interaction_bw, na.rm = T),
    interaction_en_demeaned = interaction_en - mean(interaction_en, na.rm = T),
    interaction_lu_demeaned = interaction_lu - mean(interaction_lu, na.rm = T),
    interaction_mf_demeaned = interaction_mf - mean(interaction_mf, na.rm = T),
    interaction_fh_demeaned = interaction_fh - mean(interaction_fh, na.rm = T),
    interaction_polity_demeaned = interaction_polity - mean(interaction_polity, na.rm = T),
    interaction_cc_sum_demeaned = interaction_cc_sum - mean(interaction_cc_sum, na.rm = T),
    interaction_mean = mean(log_cc_outs, na.rm = T) * mean(vdem_polyarchy, na.rm = T),
    interaction_bw_mean = mean(log_bw_outs, na.rm = T) * mean(vdem_polyarchy, na.rm = T),
    interaction_en_mean = mean(log_en_outs, na.rm = T) * mean(vdem_polyarchy, na.rm = T),
    interaction_lu_mean = mean(log_lu_outs, na.rm = T) * mean(vdem_polyarchy, na.rm = T),
    interaction_mf_mean = mean(log_mf_outs, na.rm = T) * mean(vdem_polyarchy, na.rm = T),
    interaction_fh_mean = mean(log_cc_outs, na.rm = T) * mean(fh_cl, na.rm = T),
    interaction_polity_mean = mean(log_cc_outs, na.rm = T) * mean(p_polity2, na.rm = T),
    interaction_cc_sum_mean = mean(log_cc_sum_outs, na.rm = T) * mean(vdem_polyarchy, na.rm = T)
  )%>%
  ungroup()

```

## Within-Between models: Model group 1

```{r within-between 1}

#-------------------------------------------------------------------------------
# Model group 1
#-------------------------------------------------------------------------------
m1_wb <- lmer(log_cc_outs ~ demeaned_vdem_poly + mean_vdem_poly + as.factor(year) +
                (1 | ccode), 
              data = data_s)

m2_wb <- lmer(log_cc_outs ~ demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
               mean_log_pop + mean_log_gdp_pc + mean_log_gdp_pc_sq +
               as.factor(year) + (1 | ccode),
              data = data_s[which(!is.na(data_s$vdem_polyarchy)),])

m3_wb <- lmer(log_cc_outs ~ demeaned_vdem_poly + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
                demeaned_log_pop + 
                mean_vdem_poly + mean_log_gdp_pc + mean_log_gdp_pc_sq + mean_log_pop + as.factor(year) +
                (1 | ccode), 
              data = data_s)

m4_wb <- lmer(log_cc_outs ~ demeaned_vdem_poly + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
                demeaned_log_pop + 
                mean_vdem_poly + mean_log_gdp_pc + mean_log_gdp_pc_sq + mean_log_pop + as.factor(year) +
                (1 | ccode),
               data = data_s[which(!is.na(data_s$log_pm25_pop)),])

stargazer(list(m1_wb, m2_wb, m3_wb, m4_wb), type = "text", omit = c("year"))

#-------------------------------------------------------------------------------
## Output
#-------------------------------------------------------------------------------
texreg(list(m1_wb, m2_wb, m3_wb),
       stars = c(0.01, 0.05, 0.1),
       #file = "texreg1.doc",
       custom.header = list("Pollution Outsourcing" = 1:3),
       caption = "Democracy and Pollution Outsourcing",
       label = "tab:table1",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)", 
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)", 
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}")))



```

## Plot coefficients: Model group 1

```{r plots coefficients 1}

#-------------------------------------------------------------------------------
# Coefficient plot 
#-------------------------------------------------------------------------------
# pdf("plots/Coefficients_table1_within.pdf", width = 7.5)
# par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))
# 
# modelplot(m3_wb, 
#           coef_map = c("demeaned_log_gdp_pc_sq" = "GDP per capita squ.",
#                        "demeaned_log_gdp_pc" = "GDP per capita",
#                        "demeaned_log_pop" = "Population",
#                        "demeaned_vdem_poly" = "Democracy"),
#           color = viridis(3, alpha = 0.75)[1],
#           size = 0.9,
#           linewidth = 3,
#           coef_rename = T) +
#   aes(color = ifelse(p.value < 0.05, "Significant", "Not significant")) +
#   labs(x = "Within coefficients and 95% confidence intervals") +
#   geom_errorbarh(aes(y = term, 
#                      xmin = conf.low, 
#                      xmax = conf.high,
#                      color = viridis(3, alpha = 0.75)[1]),
#                  height = 0.2, size = 1.5) +
#    scale_color_manual(values = viridis(3, alpha = 0.75)[1]) +
#   geom_vline(xintercept = 0, color = "black")
# 
# 
# dev.off()
# 
# 
# pdf("plots/Coefficients_table1_between.pdf", width = 7.5)
# par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))
# 
# modelplot(m3_wb, 
#           coef_map = c("mean_log_gdp_pc_sq" = "GDP per capita squ.",
#                        "mean_log_gdp_pc" = "GDP per capita",
#                        "mean_log_pop" = "Population",
#                        "mean_vdem_poly" = "Democracy"),
#           size = 0.9,
#           linewidth = 3,
#           coef_rename = T) +
#   labs(x = "Between coefficients and 95% confidence intervals") +
#   aes(color = ifelse(p.value < 0.05, "Significant", "Not significant")) +
#   geom_errorbarh(aes(y = term, 
#                      xmin = conf.low, 
#                      xmax = conf.high, 
#                      color = ifelse(p.value < 0.05, "Significant", "Not significant")),
#                  height = 0.2, size = 1.5) +
#   scale_color_manual(values = c("grey", viridis(3, alpha = 0.75)[1])) +
#   geom_vline(xintercept = 0, color = "black")
# 
# dev.off()

coefs_within <- as.data.frame(summary(m3_wb)$coefficients[c(2,5,3,4),])
coefs_between <- as.data.frame(summary(m3_wb)$coefficients[c(6,9,7,8),])

# Create data frames for each model
coefs_within$CI_low <- coefs_within[,"Estimate"] - qnorm(0.95)*coefs_within[,"Std. Error"]
coefs_within$CI_high <- coefs_within[,"Estimate"] + qnorm(0.95)*coefs_within[,"Std. Error"]

coefs_between$CI_low <- coefs_between[,"Estimate"] - qnorm(0.95)*coefs_between[,"Std. Error"]
coefs_between$CI_high <- coefs_between[,"Estimate"] + qnorm(0.95)*coefs_between[,"Std. Error"]


pdf("Plots/Coefficients_table1_within_between.pdf", width = 7.5)

par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))

plot(1,
     type = "n",
     ylim = c(0,2),
     bty = "n",
     xlab = "Coefficients and 95% confidence intervals",
     xlim = c(-1.75, 2.25),
     ylab = "",
     yaxt = "n",
     cex.lab = 1.1)


# add grid
segments(x0 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2), y0 = 0,
         x1 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2), y1 = 2,
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

segments(x0 = -1.5, y0 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75)),
         x1 = 2, y1 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75)),
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

# add null line
segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2.5,
         lty = "solid", lwd = 1, col = "black")


# add point estimates
points(x = coefs_within$Estimate,
       y = rev(c(0.25, 0.75, 1.25, 1.75)),
       pch = 16,
       col = c(viridis(3)[1], viridis(3)[1], viridis(3)[1], viridis(3)[1]),
       cex = 1)

# add CIs
segments(y0 = rev(c(0.25, 0.75, 1.25, 1.75)), 
         y1 = rev(c(0.25, 0.75, 1.25, 1.75)), 
         col = c(viridis(3)[1], viridis(3)[1], viridis(3)[1], viridis(3)[1]),
         x0 = coefs_within$CI_low,
         x1 = coefs_within$CI_high,
         lwd = 3, cex = 1.3, lend = 1)

# add point estimates
points(x = coefs_between$Estimate,
       y = rev(c(0.15, 0.65, 1.15, 1.65)),
       pch = 16,
       col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], viridis(3, alpha = 0.6)[2]),
       cex = 1)

# add CIs
segments(y0 = rev(c(0.15, 0.65, 1.15, 1.65)), 
         y1 = rev(c(0.15, 0.65, 1.15, 1.65)), 
         col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], viridis(3, alpha = 0.3)[2]),
         x0 = coefs_between$CI_low,
         x1 = coefs_between$CI_high,
         lwd = 3, cex = 1.3, lend = 1)

# add coefficients text
text(x = -2.75,
     y = rev(c(0.25, 0.75, 1.25, 1.75)),
     labels = c("Democracy", "Population", "GDP per capita", expression("GDP per capita"^2)),
     xpd = T,
     cex = 0.9,
     pos = 4)

# Add a legend
legend("topright", 
       legend = c("Within", "Between"), 
       col = c(viridis(3)[1],viridis(3)[2]), 
       pch = 19,
       bty = "n")

dev.off()

```

## Within-Between models: Model group 2

```{r within-between 2}

#-------------------------------------------------------------------------------
# Model group 2
#-------------------------------------------------------------------------------
m5_wb <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
               mean_log_cc_outs + mean_vdem_poly +
               as.factor(year) + (1 | ccode),
              data = data_s[which(!is.na(data_s$log_gdp_pc)),])

m6_wb <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly +
               interaction_demeaned + 
               mean_log_cc_outs + mean_vdem_poly +
               interaction_mean +
               as.factor(year) + (1 | ccode),
              data = data_s[which(!is.na(data_s$log_gdp_pc)),])

m7_wb <- lmer(log_wdi_co2 ~ demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
               mean_log_pop + mean_log_gdp_pc + mean_log_gdp_pc_sq + 
               as.factor(year) + (1 | ccode),
              data = data_s[which(!is.na(data_s$log_wdi_co2) &
                                  !is.na(data_s$log_cc_outs) &
                                  !is.na(data_s$vdem_polyarchy)),])

m8_wb <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                interaction_demeaned +
                demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                mean_log_cc_outs + mean_vdem_poly +
                interaction_mean +
                mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                as.factor(year) + (1 | ccode),
              data = data_s)

stargazer(m5_wb, m6_wb, m7_wb, m8_wb, type = "text", omit = c("ccode", "year"))

#-------------------------------------------------------------------------------
# Output
#-------------------------------------------------------------------------------
texreg(list(m5_wb, m6_wb, m7_wb, m8_wb),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg2.doc",
       custom.header = list("CO$_2$ emissions" = 1:4),
       caption = "Environmental Performance and Pollution Outsourcing",
       custom.model.names = c("Model 4", "Model 5", "Model 6", "Model 7"),
       label = "tab:table2",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "interaction_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\xmark", "\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}")))



#-------------------------------------------------------------------------------
# Model group 2 - Interaction - Check
#-------------------------------------------------------------------------------
m8_lm_int <- lm(log_wdi_co2 ~ log_cc_outs + vdem_polyarchy + 
                 log_cc_outs * vdem_polyarchy +
                 log_pop + log_gdp_pc + log_gdp_pc_sq +
                 as.factor(year) + as.factor(ccode),
                data = data_s)

stargazer(m8_wb, m8_lm_int, type = "text", omit = c("ccode", "year"))

```

## Plot coefficients: Model group 2

```{r plot coefficients 2}

#-------------------------------------------------------------------------------
# Coefficient plot - Model group 2
#-------------------------------------------------------------------------------
coefs_within2 <- as.data.frame(summary(m8_wb)$coefficients[2:7,])
coefs_between2 <- as.data.frame(summary(m8_wb)$coefficients[8:13,])

# Create data frames for each model
coefs_within2$CI_low <- coefs_within2[,"Estimate"] - qnorm(0.95)*coefs_within2[,"Std. Error"]
coefs_within2$CI_high <- coefs_within2[,"Estimate"] + qnorm(0.95)*coefs_within2[,"Std. Error"]

coefs_between2$CI_low <- coefs_between2[,"Estimate"] - qnorm(0.95)*coefs_between2[,"Std. Error"]
coefs_between2$CI_high <- coefs_between2[,"Estimate"] + qnorm(0.95)*coefs_between2[,"Std. Error"]


pdf("Plots/Coefficients_table2_within_between.pdf", width = 7.5)

par(mar = c(5.1, 10, 2.5, 2.1)) # c(bottom, left, top, right))

plot(1,
     type = "n",
     ylim = c(0,2.5),
     bty = "n",
     xlab = "Coefficients and 95% confidence intervals",
     xlim = c(-0.95, 1.1),
     ylab = "",
     yaxt = "n",
     cex.lab = 1.1)


# add grid
segments(x0 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2), y0 = 0,
         x1 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2), y1 = 2.5,
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

segments(x0 = -1.5, y0 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         x1 = 2, y1 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

# add null line
segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2.5,
         lty = "solid", lwd = 1, col = "black")


# add point estimates
points(x = coefs_within2$Estimate,
       y = rev(c(0.25, 0.65, 1.05, 1.45, 1.85, 2.25)),
       pch = 16,
       col = c(viridis(3)[1], viridis(3)[1],viridis(3)[1],viridis(3)[1], viridis(3, alpha = 0.6)[1],viridis(3, alpha = 0.6)[1]),
       cex = 1)

# add CIs
segments(y0 = rev(c(0.25, 0.65, 1.05, 1.45, 1.85, 2.25)), 
         y1 = rev(c(0.25, 0.65, 1.05, 1.45, 1.85, 2.25)), 
         col = c(viridis(3)[1], viridis(3)[1], viridis(3)[1],viridis(3)[1], viridis(3, alpha = 0.3)[1],viridis(3, alpha = 0.3)[1]),
         x0 = coefs_within2$CI_low,
         x1 = coefs_within2$CI_high,
         lwd = 3, cex = 1.3, lend = 1)

# add point estimates
points(x = coefs_between2$Estimate,
       y = rev(c(0.15, 0.55, 0.95, 1.35, 1.75, 2.15)),
       pch = 16,
       col = c(viridis(3, alpha = 0.6)[2], viridis(3)[2],viridis(3)[2],viridis(3)[2],
               viridis(3, alpha = 0.6)[2], viridis(3, alpha = 0.6)[2]),
       cex = 1)

# add CIs
segments(y0 = rev(c(0.15, 0.55, 0.95, 1.35, 1.75, 2.15)), 
         y1 = rev(c(0.15, 0.55, 0.95, 1.35, 1.75, 2.15)), 
         col = c(viridis(3, alpha = 0.3)[2], viridis(3)[2],viridis(3)[2],viridis(3)[2],
                 viridis(3, alpha = 0.3)[2], viridis(3, alpha = 0.3)[2]),
         x0 = coefs_between2$CI_low,
         x1 = coefs_between2$CI_high,
         lwd = 3, cex = 1.3, lend = 1)

# add coefficients text
text(x = -1.85,
     y = rev(c(0.25, 0.65, 1.05, 1.45, 1.85, 2.25)),
     labels = c("Pollution outsourcing", "Democracy", "Pollution outsourcing x Democracy", 
                "Population", "GDP per capita", expression("GDP per capita"^2)),
     xpd = T,
     cex = 0.9,
     pos = 4)

# Add a legend
legend("topright", 
       legend = c("Within", "Between"), 
       col = c(viridis(3)[1], viridis(3)[2]), 
       pch = 19,
       bty = "n")

dev.off()

```


```{r plots within-between separate}

#-------------------------------------------------------------------------------
# Coefficient plot - Within
#-------------------------------------------------------------------------------
coefs_low <- as.data.frame(summary(m8_dem_low)$coefficients[2:5,])
coefs_high <- as.data.frame(summary(m8_dem_high)$coefficients[2:5,])

# Create data frames for each model
coefs_low$CI_low <- coefs_low[,"Estimate"] - qnorm(0.95)*coefs_low[,"Std. Error"]
coefs_low$CI_high <- coefs_low[,"Estimate"] + qnorm(0.95)*coefs_low[,"Std. Error"]

coefs_high$CI_low <- coefs_high[,"Estimate"] - qnorm(0.95)*coefs_high[,"Std. Error"]
coefs_high$CI_high <- coefs_high[,"Estimate"] + qnorm(0.95)*coefs_high[,"Std. Error"]


pdf("Plots/Coefficients_table2_within.pdf", width = 7.5)

par(mar = c(5.1, 9, 2.5, 2.1)) # c(bottom, left, top, right))

plot(1,
     type = "n",
     ylim = c(0,2.5),
     bty = "n",
     xlab = "Within coefficients and 95% confidence intervals",
     xlim = c(-0.6, 1.5),
     ylab = "",
     yaxt = "n",
     cex.lab = 1.1)


# add grid
segments(x0 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25), y0 = 0,
         x1 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25), y1 = 2.5,
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

segments(x0 = -1.5, y0 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         x1 = 1.5, y1 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

# add null line
segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2.5,
         lty = "solid", lwd = 1, col = "black")


# add point estimates
points(x = coefs_low$Estimate,
       y = rev(c(0.25, 0.75, 1.5, 2.25)),
       pch = 16,
       col = c(viridis(3)[1], viridis(3, alpha = 0.6)[1], viridis(3)[1], viridis(3)[1]),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         y1 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         col = c(viridis(3)[1], viridis(3, alpha = 0.3)[1], viridis(3)[1], viridis(3)[1]),
         x0 = coefs_low$CI_low,
         x1 = coefs_low$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add point estimates
points(x = coefs_high$Estimate,
       y = rev(c(0.15, 0.65, 1.4, 2.15)),
       pch = 16,
       col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], viridis(3)[2]),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         y1 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], viridis(3)[2]),
         x0 = coefs_high$CI_low,
         x1 = coefs_high$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add coefficients text
text(x = -1.25,
     y = rev(c(0.25, 0.75, 1.5, 2.25)),
     labels = c("Pollution outsourcing", "Population", "GDP per capita", expression("GDP per capita"^2)),
     xpd = T,
     cex = 0.9,
     pos = 4)

# Add a legend
legend("topright", 
       legend = c("Less democratic", "More democratic"), 
       col = c(viridis(3)[1], viridis(3)[2]), 
       pch = 19,
       bty = "n")

dev.off()


#-------------------------------------------------------------------------------
# Coefficient plot - Between
#-------------------------------------------------------------------------------
coefs_low2 <- as.data.frame(summary(m9_dem_low)$coefficients[6:9,])
coefs_high2 <- as.data.frame(summary(m9_dem_high)$coefficients[6:9,])

# Create data frames for each model
coefs_low2$CI_low <- coefs_low2[,"Estimate"] - qnorm(0.95)*coefs_low2[,"Std. Error"]
coefs_low2$CI_high <- coefs_low2[,"Estimate"] + qnorm(0.95)*coefs_low2[,"Std. Error"]

coefs_high2$CI_low <- coefs_high2[,"Estimate"] - qnorm(0.95)*coefs_high2[,"Std. Error"]
coefs_high2$CI_high <- coefs_high2[,"Estimate"] + qnorm(0.95)*coefs_high2[,"Std. Error"]


pdf("Plots/Coefficients_table2_between.pdf", width = 7.5)

par(mar = c(5.1, 9, 2.5, 2.1)) # c(bottom, left, top, right))

plot(1,
     type = "n",
     ylim = c(0,2.5),
     bty = "n",
     xlab = "Between coefficients and 95% confidence intervals",
     xlim = c(-1, 1.75),
     ylab = "",
     yaxt = "n",
     cex.lab = 1.1)


# add grid
segments(x0 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5), y0 = 0,
         x1 = c(-1.25,-1,-0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25, 1.5), y1 = 2.5,
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

segments(x0 = -1.5, y0 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         x1 = 1.5, y1 = rev(c(0.25, 0.5, 0.75, 1,
                               1.25, 1.5, 1.75, 2, 2.25)),
         col = "lightgrey",
         lty = "solid", lwd = 0.7)

# add null line
segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2.5,
         lty = "solid", lwd = 1, col = "black")


# add point estimates
points(x = coefs_low2$Estimate,
       y = rev(c(0.25, 0.75, 1.5, 2.25)),
       pch = 16,
       col = c(viridis(3, alpha = 0.6)[1], viridis(3)[1], viridis(3, alpha = 0.6)[1], viridis(3)[1]),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         y1 = rev(c(0.25, 0.75, 1.5, 2.25)), 
         col = c(viridis(3, alpha = 0.3)[1], viridis(3,)[1], viridis(3, alpha = 0.3)[1], viridis(3)[1]),
         x0 = coefs_low2$CI_low,
         x1 = coefs_low2$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add point estimates
points(x = coefs_high2$Estimate,
       y = rev(c(0.15, 0.65, 1.4, 2.15)),
       pch = 16,
       col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], viridis(3, alpha = 0.6)[2]),
       cex = 1.25)

# add CIs
segments(y0 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         y1 = rev(c(0.15, 0.65, 1.4, 2.15)), 
         col = c(viridis(3)[2], viridis(3)[2], viridis(3)[2], viridis(3, alpha = 0.3)[2]),
         x0 = coefs_high2$CI_low,
         x1 = coefs_high2$CI_high,
         lwd = 3, cex = 1.5, lend = 1)

# add coefficients text
text(x = -1.95,
     y = rev(c(0.25, 0.75, 1.5, 2.25)),
     labels = c("Pollution outsourcing", "Population", "GDP per capita", expression("GDP per capita"^2)),
     xpd = T,
     cex = 0.9,
     pos = 4)

# Add a legend
legend("topright", 
       legend = c("Less democratic", "More democratic"), 
       col = c(viridis(3)[1], viridis(3)[2]), 
       pch = 19,
       bty = "n")

dev.off()


```



# Quantities of interest

## Simulated interaction & marginal effects

```{r plots simulated interaction effect}

#-------------------------------------------------------------------------------
# Simulate interaction effect 
#-------------------------------------------------------------------------------
nsim <- 1000
beta_hat <- coef(m8_out_dem_int_c)
V_hat <- vcov(m8_out_dem_int_c)
S <- mvrnorm(nsim, beta_hat, V_hat)
quants_S <- apply(S, 2, quantile, probs = c(0.025, 0.5, 0.975))

## Plot interaction term
pdf("plots/sim_interact_outsource_dem.pdf")

plot(density(S[,"log_cc_outs:vdem_polyarchy"]),
     las = 1,
     lwd = 3,
     col = viridis(4)[1],
     bty = "n",
     cex = 1.1,
     cex.lab = 1.3,
     yaxt = "n",
     ylab = "Density",
     main = "Pollution Outsourcing x Democracy",
     xlab = "Simulated Interaction Effect")

abline(v = c(quants_S[c(1,3), "log_cc_outs:vdem_polyarchy"]), lty = 2, col = viridis(3)[2])
abline(v = c(quants_S[2,"log_cc_outs:vdem_polyarchy"]), lty = 1, lwd = 1.5, col = viridis(3)[2])
abline(v = 0, lty = 1, lwd = 1, col = "black")

legend("topleft",
       lty = c("solid", "dashed"),
       col = c(viridis(3)[2], viridis(3)[2]),
       legend = c("Mean", "95% CIs"),
       bty = "n")

dev.off()


#-------------------------------------------------------------------------------
# Simulate marginal effects 
#-------------------------------------------------------------------------------

# library(marginaleffects)
# library(ggExtra)
# library(cowplot)
# 
# base_plot <-
#   plot_cme(m8_out_dem_int_c,
#          variables = "log_cc_outs",
#          condition = "vdem_polyarchy",
#          conf_level = 0.95) +
# ggtitle("Marginal Effect at the Mean of Pollution Outsourcing") +
# theme_bw() +
# theme(panel.border = element_blank(),
#       axis.title.x = element_text(size = 15),
#       axis.title.y = element_text(size = 15),
#       axis.text = element_text(size = 13),
#       plot.title = element_text(size = 17, face = "bold", hjust = 0.5)) +
# geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
# xlab("Democracy") +
# ylab("Marginal Effect of Pollution Outsourcing")
# 
# # Create the histogram plot for the x-axis variable
# hist_plot <- ggplot(data_s, aes(x = vdem_polyarchy)) +
#   geom_histogram(bins = 30, fill = viridis(1, alpha = 0.25), color = viridis(1, alpha = 0.75)) +
#   theme_void()
# 
# # Combine the base plot and histogram plot using cowplot
# combined_plot <- ggdraw() +
#   draw_plot(base_plot, x = 0, y = 0, width = 1, height = 0.8) +
#   draw_plot(hist_plot, x = 0.09, y = 0.07, width = 0.9, height = 0.2)
# 
# # Print the combined plot
# pdf("plots/Marginal_outsource_dem_1.pdf")
# par(mar = c(2.5, 2.4,0, 2.1)) # c(bottom, left, top, right))
# combined_plot
# dev.off()


pdf("plots/Marginal_outsource_dem_2.pdf")

interplot(m6_out_dem_int,
          var1 = "log_cc_outs",
          var2 = "vdem_polyarchy",
          hist = T,
          ci = 0.95,
          sims = 1000,
          ercolor = viridis(1, alpha = 0.75),
          rfill = viridis(1, alpha = 0.05),
          ralpha = 0.25) +
  xlab("Democracy") +
  ylab("Marginal Effect") +
  ggtitle("Marginal Effect at the Mean of Pollution Outsourcing") +
  theme_bw() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  theme(axis.line = element_line(colour = "black"),
        axis.title.x = element_text(size = 15),
        axis.title.y = element_text(size = 15),
        axis.text = element_text(size = 13),
        plot.title = element_text(size = 17, hjust = 0.5),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

dev.off()


## Alternatively
library(margins)
library(broom)
library(ggExtra)

meff <- margins(m6_out_dem_int, variables = "log_cc_outs", at = list(vdem_polyarchy = seq(0.016, 0.926, length.out = 30)))
meff_df <- as.data.frame(summary(meff))

p <- ggplot(meff_df, aes(x = vdem_polyarchy, y = AME)) +
  geom_line() +
  geom_ribbon(aes(ymin = AME - 1.96 * SE, ymax = AME + 1.96 * SE), alpha = 0.2) +
  labs(x = "Democracy (vdem_polyarchy)", y = "Marginal Effect of Pollution Outsourcing", 
       title = "Marginal Effect of Pollution Outsourcing on Pollution") +
  theme_minimal()

# Add the marginal histogram
p_with_hist <- ggMarginal(p, type = "histogram", margins = "x", size = 5, bins = 30, fill = "blue", alpha = 0.5)

print(p)

```

## Simulate expected values and first differences: Model group 1 (Within)

```{r expected values 1, within}

#-------------------------------------------------------------------------------
# Get X for observed value approach
#-------------------------------------------------------------------------------
extract_ccode <- m3_outsource_c$model$`as.factor(ccode)` ## extract included countries
extract_year <- m3_outsource_c$model$`as.factor(year)`   ## extract included years

## Create dummy variables for countries and years
data_ova <- dummy_cols(data_s[which(data_s$ccode %in% extract_ccode &  
                                    data_s$year %in% extract_year),],
                       select_columns = c("ccode", "year"))



## Reduce to correct length
data_ova <- data_ova[which(!is.na(data_ova$vdem_polyarchy) &
                           !is.na(data_ova$log_cc_outs) &
                           !is.na(data_ova$log_pop) &
                           !is.na(data_ova$log_gdp_pc)),]

## make sure to select correct columns for the dummies
first_year <- which(colnames(data_ova) == "year_1991")
last_year <- which(colnames(data_ova) == "year_2015")
first_ccode <- which(colnames(data_ova) == "ccode_8")
last_ccode <- which(colnames(data_ova) == "ccode_894")

## Get X
X <- as.matrix(cbind(1,
                     data_ova$vdem_polyarchy, 
                     data_ova$log_pop,
                     data_ova$log_gdp_pc,
                     data_ova$log_gdp_pc_sq,
                     data_ova[,c(first_year:last_year)],
                     data_ova[,c(first_ccode:last_ccode)]))

## Check dimensions
X <- na.omit(X)
dim(X)

## Get colnames
colnames(X) <- names(coef(m3_outsource_c))

#-------------------------------------------------------------------------------
# Install simulation github Rittmann et al. (2023)
#-------------------------------------------------------------------------------
install_github("mneunhoe/simloglm")
library (simloglm)

## Function to sample from inverse gamma distribution
rinvgamma <- function(n, shape, rate = 1, scale = 1/rate){
  if(missing(rate) && !missing(scale))
    rate <- 1/scale
  1/stats::rgamma(n, shape, rate)
}

## Set up informal posterior of coefficients
nsim <- 1000 # number of draws
beta_hat <- coef(m3_outsource_c)
sigma_hat <- summary(m3_outsource_c)$sigma
X_prime_X <- summary(m3_outsource_c)$cov.unscaled

## First sigma^2
set.seed(199610)
sigma2_tilde <- rinvgamma(nsim,
                          shape = m3_outsource_c$df.residual/2,
                          rate = (sigma_hat^2*m3_outsource_c$df.residual)/2)

# Now the betas
beta_tilde <- matrix(NA,
                     nrow = nsim,
                     ncol = length(beta_hat))

for(sim in 1:nsim){
  beta_tilde[sim, ] <-
    MASS::mvrnorm(1, beta_hat, X_prime_X * sigma2_tilde[sim])
}


#-------------------------------------------------------------------------------
# Set scenarios: over range of democracy
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Determine "reasonable" variation of democracy variable
range_dem <- aggregate(data_ova$vdem_polyarchy,
                       by = list(data_ova$cname),
                       FUN = range)

names(range_dem) <- c("country", "range")

# get the difference
range_dem$diff <- range_dem$range[,2]- range_dem$range[,1]

# get the respective country
max_range_dem_country <- range_dem$country[which.max(range_dem$diff)]

# and the respective values (min and max > used for setting the scenario)
min_dem <- range_dem$range[,1][which.max(range_dem$diff)]
max_dem <- range_dem$range[,2][which.max(range_dem$diff)]

range_dem <- as.vector(seq(min_dem, max_dem, length.out = 30))


# Create empty matrix to store the scenarios
cases <- array(NA, 
               c(dim(X), length(range_dem)))

# Copy in our X
cases[,,] <- X # because OVA not Average case!

# Select: Democracy over range
select <- which(colnames(X) == "vdem_polyarchy")

for(i in 1:length(range_dem)){
  cases[ ,select, i] <- range_dem[i]
}

head(cases)
dim(cases) 

# check dimensions 
# 3933 rows/datapoints
# 190 variables (incl. country and year dummies)
# 30 scenarios

# Calculate linear predictor on log scale & retransform
E_Y_c_dem <- matrix(NA, nrow = nsim, ncol = length(range_dem)) # empty matrix for storage

for(i in 1:length(range_dem)){              # 30 rounds (for range of dem variable)
  ev <- beta_tilde %*% t(cases[,,i])        # calculate linear predictor on log scale
  ev_plus_gamma <- ev + 1/2*sigma2_tilde    # add draws of 1/2*sigma2_tilde
  ev_transf <- exp(ev_plus_gamma)           # transform
  ev_transf_m <- ev_transf #- 1              # E(y) - 1
  tmp_val <- apply(ev_transf_m, 1, mean)    # now average results
  E_Y_c_dem[,i] <- tmp_val                  # store in val object
}

# Summarize to get CIs
CI_E_Y_c_dem <- apply(E_Y_c_dem, 2, quantile, c(0.025, 0.975))

# Now get the point estimates 
E_Y_c_hat_dem <- matrix(NA, nrow = length(range_dem), ncol = 1)

for(i in 1:length(range_dem)){                         # 30 rounds (for range of dem variable)
  ev_point <- beta_hat %*% t(cases[,,i])               # use beta_hat (not simulated)
  ev_point_plus_gamma <- ev_point + 1/2*sigma_hat^2    # use sigma_hat (not simulated)
  ev_point_transf <- exp(ev_point_plus_gamma)          # transform
  ev_point_transf_m <- ev_point_transf #- 1             # E(y) - 1
  tmp_val_point <- apply(ev_point_transf_m, 1, mean)   # now average results
  E_Y_c_hat_dem[i,] <- tmp_val_point                   # store in val object
}


#-------------------------------------------------------------------------------
# Plot: Expected values of pollution outsourcing (on original scale)
#-------------------------------------------------------------------------------

pdf("plots/Expected value_dem.pdf") 

par(mar = c(5.1, 4.7, 4.1, 2.1)) # c(bottom, left, top, right))

plot(range_dem,
     E_Y_c_hat_dem,
     type = "n",
     ylim = c(59, 75),
     xlim = c(min_dem, max_dem),
     ylab = expression("Pollution Outsourcing [Gg]"),
     xlab = "Democracy",
     bty = "n",
     main = NULL,
     cex.lab = 1.3)

segments(x0 = range_dem, x1 = range_dem,
         y1 = CI_E_Y_c_dem[2,], y0 = CI_E_Y_c_dem[1,],
         col = viridis(1, 0.25),
         lwd = 4, lend = 1)

points(range_dem, E_Y_c_hat_dem, col = viridis(1, 0.8), pch = 20,
       cex = 1.5)


# Add a "histogram" of actual X1-values.
axis(1,
     at = data_ova$vdem_polyarchy,
     col.ticks = "gray30",
     labels = FALSE,
     tck = 0.02)

dev.off()


#-------------------------------------------------------------------------------
# First difference
#-------------------------------------------------------------------------------

## First difference: Democracy high - low
FD_dem_hat <- E_Y_c_hat_dem[30,] - E_Y_c_hat_dem[1,]  ## max - min
FD_dem <- E_Y_c_dem[,30] - E_Y_c_dem[,1] 
CI_FD_dem <- quantile(FD_dem, c(0.025, 0.975))


#-------------------------------------------------------------------------------
## How "big" is the difference compared to variation in the dataset?
#-------------------------------------------------------------------------------
sd_outs <- aggregate(data_ova$cf_cc_pop_mean_outs,
                     by = list(data_ova$cname),
                     FUN = sd)

mean_within_country_sd <- mean(sd_outs[,2], na.rm = T)
share_FD_var <- FD_dem_hat / mean_within_country_sd

```

## Simulate expected values and first differences: Model group 1 (Between)

```{r expected values 1, between}

#-------------------------------------------------------------------------------
# Start with set-up for retransformation
#-------------------------------------------------------------------------------
fixef(m3_wb)
ranef(m3_wb)

# Set up informal posterior of coefficients
nsim <- 1000 # number of draws

beta_hat_b <- c()

for(i in 1:length(fixef(m3_wb))){
  beta_hat_b[i] <- c(fixef(m3_wb)[[i]])
}

sigma_hat_b <- summary(m3_wb)$sigma
X_prime_X_b <- as.matrix(vcov(m3_wb)) / summary(m3_wb)$sigma^2 ## equivalent to vcov$unscaled

# First sigma^2
set.seed(199610)
sigma2_tilde_b <- rinvgamma(nsim,
                            shape = df.residual(m3_wb)/2,
                            rate = (sigma_hat_b^2*df.residual(m3_wb))/2)

# Now the betas
beta_tilde_b <- matrix(NA,
                       nrow = nsim,
                       ncol = length(beta_hat_b))

for(sim in 1:nsim){
  beta_tilde_b[sim, ] <-
    MASS::mvrnorm(1, beta_hat_b, X_prime_X_b * sigma2_tilde_b[sim])
}

# Set scenarios
scen_1_min_b <- cbind(1,
                      mean(data_ova$demeaned_vdem_poly, na.rm = T),
                      mean(data_ova$demeaned_log_gdp_pc, na.rm = T),
                      mean(data_ova$demeaned_log_gdp_pc_sq, na.rm = T),
                      mean(data_ova$demeaned_log_pop, na.rm = T),
                      min(data_ova$mean_vdem_poly, na.rm = T),
                      mean(data_ova$mean_log_gdp_pc, na.rm = T),
                      mean(data_ova$mean_log_gdp_pc_sq, na.rm = T),
                      mean(data_ova$mean_log_pop, na.rm = T),
                      median(data_ova$year_1991, na.rm = T),
                      median(data_ova$year_1992, na.rm = T),
                      median(data_ova$year_1993, na.rm = T),
                      median(data_ova$year_1994, na.rm = T),
                      median(data_ova$year_1995, na.rm = T),
                      median(data_ova$year_1996, na.rm = T),
                      median(data_ova$year_1997, na.rm = T),
                      median(data_ova$year_1998, na.rm = T),
                      median(data_ova$year_1999, na.rm = T),
                      median(data_ova$year_2000, na.rm = T),
                      median(data_ova$year_2001, na.rm = T),
                      median(data_ova$year_2002, na.rm = T),
                      median(data_ova$year_2003, na.rm = T),
                      median(data_ova$year_2004, na.rm = T),
                      median(data_ova$year_2005, na.rm = T),
                      median(data_ova$year_2006, na.rm = T),
                      median(data_ova$year_2007, na.rm = T),
                      median(data_ova$year_2008, na.rm = T),
                      median(data_ova$year_2009, na.rm = T),
                      median(data_ova$year_2010, na.rm = T),
                      median(data_ova$year_2011, na.rm = T),
                      median(data_ova$year_2012, na.rm = T),
                      median(data_ova$year_2013, na.rm = T),
                      median(data_ova$year_2014, na.rm = T),
                      median(data_ova$year_2015, na.rm = T)
                      )

# colnames
colnames(scen_1_min_b) <- names(fixef(m3_wb))

# copy existing scenario1 into new object scenario2 
scen_1_max_b <- scen_1_min_b

# switch only the changing values to get scenario with max inequ
scen_1_max_b[, which(colnames(scen_1_max_b) == "mean_vdem_poly")] <- max(data_ova$mean_vdem_poly, na.rm = T)


#-------------------------------------------------------------------------------
# Sample-specific means (understandable scenario)
#-------------------------------------------------------------------------------
# min(data_scen$mean_inequ)                   ## 0.29
# max(data_scen$mean_inequ)                   ## 0.68
# unique(data_scen$country[which(data_scen$mean_inequ == min(data_scen$mean_inequ))]) ## Netherlands
# unique(data_scen$country[which(data_scen$mean_inequ == max(data_scen$mean_inequ))]) ## Namibia
# mean(exp(data_scen$mean_income))            ## 13 326
# mean(data_scen$mean_winning)                ## 0.71
# mean(data_scen$mean_trade)                  ## 0.84
# mean(data_scen$mean_cpi)                    ## 4.31
# mean(data_scen$mean_industrial, na.rm = T)  ## 0.28
# mean(exp(data_scen$mean_pop))               ## 184

X_c_b <- rbind(scen_1_max_b, scen_1_min_b)

# Calculate the linear predictor on log scale
X_beta_b <- beta_tilde_b %*% t(X_c_b)

# Now transform back to original scale

# First add draws of 1/2*sigma2_tilde to each column
X_beta_sigma_tilde_b <- apply(X_beta_b, 2, function(x) x + 1/2*sigma2_tilde_b)

# Transform
E_Y_c_b <- exp(X_beta_sigma_tilde_b)

# Summarize to get CIs
CI_E_Y_c_b <- apply(E_Y_c_b, 2, quantile, c(0.025, 0.975))

# Use beta_hat and sigma_hat for point estimates
X_beta_hat_b <- beta_hat_b %*% t(X_c_b)
X_beta_sigma_hat_b <- X_beta_hat_b + 1/2*sigma_hat_b^2

# Point estimate
E_Y_c_hat_b <- exp(X_beta_sigma_hat_b)

# First difference
FD_max_min_hat_b <- E_Y_c_hat_b[,1] - E_Y_c_hat_b[,2]
FD_max_min_b <- E_Y_c_b[,1] - E_Y_c_b[,2]
CI_FD_max_min_b <- quantile(FD_max_min_b, c(0.025, 0.975))

summary(data_s$cf_cc_pop_mean_outs)

#-------------------------------------------------------------------------------
# How "big" is the first difference compared to the SD of the DV?
#-------------------------------------------------------------------------------
mean_pm25_bc <- aggregate(data_ova$PM25_pop_weighed,
                          by = list(data_scen$country),
                          FUN = mean, na.rm = T)

colnames(mean_pm25_bc)[1:2] <- c("country", "mean")
sd_pm25_b <- sd(mean_pm25_bc$mean)
share_fd_sd_b <- FD_max_min_hat_b/sd_pm25_b


#-------------------------------------------------------------------------------
# Plot
#-------------------------------------------------------------------------------

pdf("Plots/EV_max_min_between.pdf")

# First plot: EV density
plot(density(E_Y_c_b[,1]),
     bty = "n",
     xlim = c(0,41),
     main = NA,
     las = 1,
     ylim = c(0,0.2),
     yaxt = "n",
     cex = 1.1,
     cex.lab = 1.3,
     xlab = "Outsourcing [Gigagrams]",
     type = "n")

polygon(density(E_Y_c_b[,1]),
        col = viridis(3, alpha = 0.4)[1],
        border = F,
        main = NULL)

polygon(density(E_Y_c_b[,2]),
        col = viridis(3, alpha = 0.4)[2],
        border = F,
        main = NULL)

lines(density(E_Y_c_b[,1]),
      col = viridis(3)[1])

lines(density(E_Y_c_b[,2]),
      col = viridis(3)[2])

abline(v = c(E_Y_c_hat_b[,1],
             E_Y_c_hat_b[,2]),
       lty = 2, lwd = 2,
       col = c(viridis(3)[1],
               viridis(3)[2]))

legend("topright",
       legend = c("Max. Democracy",
                  "Min. Democracy"),
       col = c(viridis(3, alpha = 0.5)[1],
               viridis(3, alpha = 0.5)[2]),
       pch = 19,
       cex = 1.1,
       bty = "n")

dev.off()


# Second plot: First difference
pdf("Plots/FD_max_min_between.pdf")

plot(y = 1,
     x = FD_max_min_hat_b,
     col = "darkgrey",
     ylim = c(0,2),
     xlim = c(-5.5,11),
     xlab = "",
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1, x0 = CI_FD_max_min_b[1],
         y1 = 1, x1 = CI_FD_max_min_b[2],
         col = adjustcolor("darkgrey", alpha = 0.4),
         lwd = 12, cex = 1.5, lend = 1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 2,
         lty = "dashed", lwd = 2)

text(x = FD_max_min_hat_b+0.5,
     y = 0.8,
     labels = c("First Difference"),
     cex = 1.3)

text(x = FD_max_min_hat_b+0.5,
     y = 0.65,
     labels = c("(Max - Min)"),
     cex = 0.9)

dev.off()

```

## Simulate expected values and first differences: Model group 2

```{r expected values 2}

#-------------------------------------------------------------------------------
# Get X for observed value approach
#-------------------------------------------------------------------------------
extract_ccode2 <- m8_out_dem_int_c$model$`as.factor(ccode)` ## extract included countries
extract_year2 <- m8_out_dem_int_c$model$`as.factor(year)`   ## extract included years

## Create dummy variables for countries and years
data_ova2 <- dummy_cols(data_s[which(data_s$ccode %in% extract_ccode2 &  
                                     data_s$year %in% extract_year2),],
                        select_columns = c("ccode", "year"))



## Reduce to correct length
data_ova2 <- data_ova2[which(!is.na(data_ova2$vdem_polyarchy) &
                             !is.na(data_ova2$log_cc_outs) &
                             !is.na(data_ova2$log_pop) &
                             !is.na(data_ova2$log_gdp_pc) &
                             !is.na(data_ova2$log_pm25_pop)),]

## make sure to select correct columns for the dummies
first_year2 <- which(colnames(data_ova2) == "year_1999")
last_year2 <- which(colnames(data_ova2) == "year_2015")
first_ccode2 <- which(colnames(data_ova2) == "ccode_8")
last_ccode2 <- which(colnames(data_ova2) == "ccode_894")

## Get X
X2 <- as.matrix(cbind(1,
                      data_ova2$log_cc_outs,
                      data_ova2$vdem_polyarchy, 
                      data_ova2$log_pop,
                      data_ova2$log_gdp_pc,
                      data_ova2$log_gdp_pc_sq,
                      data_ova2[,c(first_year2:last_year2)],
                      data_ova2[,c(first_ccode2:last_ccode2)],
                      data_ova2$log_cc_outs * data_ova2$vdem_polyarchy))

## Check dimensions
X2 <- na.omit(X2)
dim(X2)

## Get colnames
colnames(X2) <- names(coef(m8_out_dem_int_c))

#-------------------------------------------------------------------------------
# Follow Rittmann et al.'s instructions
#-------------------------------------------------------------------------------

## Set up informal posterior of coefficients
beta_hat2 <- coef(m8_out_dem_int_c)
sigma_hat2 <- summary(m8_out_dem_int_c)$sigma
X_prime_X2 <- summary(m8_out_dem_int_c)$cov.unscaled

## First sigma^2
set.seed(199610)
sigma2_tilde2 <- rinvgamma(nsim,
                           shape = m8_out_dem_int_c$df.residual/2,
                           rate = (sigma_hat2^2*m8_out_dem_int_c$df.residual)/2)

# Now the betas
beta_tilde2 <- matrix(NA,
                      nrow = nsim,
                      ncol = length(beta_hat2))

for(sim in 1:nsim){
  beta_tilde2[sim, ] <-
    MASS::mvrnorm(1, beta_hat2, X_prime_X2 * sigma2_tilde2[sim])
}


#-------------------------------------------------------------------------------
# Determine "reasonable" variation of outsourcing
range_outsource <- aggregate(data_ova2$log_cc_outs,
                             by = list(data_ova2$cname),
                             FUN = range)

names(range_outsource) <- c("country", "range")

# get the difference
range_outsource$diff <- range_outsource$range[,2]-range_outsource$range[,1]

# get the respective country
max_range_outsource_country <- range_outsource$country[which.max(range_outsource$diff)]

# and the respective values (min and max > used for setting the scenario)
min_outsource <- range_outsource$range[,1][which.max(range_outsource$diff)]
max_outsource <- range_outsource$range[,2][which.max(range_outsource$diff)]


#-------------------------------------------------------------------------------
# Determine "reasonable" variation of dem
range_dem2 <- aggregate(data_ova2$vdem_polyarchy,
                        by = list(data_ova2$cname),
                        FUN = range)

names(range_dem2) <- c("country", "range")

# get the difference
range_dem2$diff <- range_dem2$range[,2]- range_dem2$range[,1]

# get the respective country
max_range_dem_country2 <- range_dem2$country[which.max(range_dem2$diff)]

# and the respective values (min and max > used for setting the scenario)
min_dem2 <- range_dem2$range[,1][which.max(range_dem2$diff)]
max_dem2 <- range_dem2$range[,2][which.max(range_dem2$diff)]

range_dem2 <- as.vector(seq(min_dem, max_dem, length.out = 30))



#-------------------------------------------------------------------------------
## Create empty matrix to store the scenarios
cases2 <- array(NA, 
                c(dim(X2), 4))

## Copy in our X
cases2[,,] <- X2 

## Add names
colnames(cases2) <- names(beta_hat2)

## Case 1: min dem & min outsource
cases2[ ,"vdem_polyarchy", 1] <- min_dem2
cases2[ ,"log_cc_outs", 1] <- min_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 1] <- min_dem2*min_outsource

## Case 2: min dem & max outsource
cases2[ ,"vdem_polyarchy", 2] <- min_dem2
cases2[ ,"log_cc_outs", 2] <- max_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 2] <- min_dem2*max_outsource

## Case 3: max dem & min outsource
cases2[ ,"vdem_polyarchy", 3] <- max_dem2
cases2[ ,"log_cc_outs", 3] <- min_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 3] <- max_dem2*min_outsource

## Case 4: max dem & max outsource
cases2[ ,"vdem_polyarchy", 4] <- max_dem2
cases2[ ,"log_cc_outs", 4] <- max_outsource
cases2[ ,"log_cc_outs:vdem_polyarchy", 4] <- max_dem2*max_outsource


#-------------------------------------------------------------------------------
## Calculate linear predictor on log scale & retransform
#-------------------------------------------------------------------------------
E_Y_c2 <- matrix(NA, nrow = nsim, ncol = 4)  # empty matrix for storage

for(i in 1:4){                              # four rounds (for scenarios)
  ev <- beta_tilde2 %*% t(cases2[,,i])      # calculate linear predictor on log scale
  ev_plus_gamma <- ev + 1/2*sigma2_tilde2   # add draws of 1/2*sigma2_tilde
  ev_transf <- exp(ev_plus_gamma)           # transform
  ev_transf_m <- ev_transf                  # E(y) 
  tmp_val <- apply(ev_transf_m, 1, mean)    # now average results
  E_Y_c2[,i] <- tmp_val                     # store in val object
}

## Summarize to get CIs
CI_E_Y_c2 <- apply(E_Y_c2, 2, quantile, c(0.025, 0.5, 0.975))

## Now get the point estimates 
E_Y_c_hat2 <- matrix(NA, nrow = 4, ncol = 1)

for(i in 1:4){                                       # four rounds (for scenarios)
  ev_point <- beta_hat2 %*% t(cases2[,,i])           # use beta_hat (not simulated)
  ev_point_plus_gamma <- ev_point + 1/2*sigma_hat2^2 # use sigma_hat (not simulated)
  ev_point_transf <- exp(ev_point_plus_gamma)        # transform
  ev_point_transf_m <- ev_point_transf               # E(y)
  tmp_val_point <- apply(ev_point_transf_m, 1, mean) # now average results
  E_Y_c_hat2[i,] <- tmp_val_point                    # store
}


#-------------------------------------------------------------------------------
## First differences
#-------------------------------------------------------------------------------

## First difference: Democracy low -> Outsource max - min
FD_dem_low_hat <- E_Y_c_hat2[2,] - E_Y_c_hat2[1,]  ## max - min
FD_dem_low <- E_Y_c2[,2] - E_Y_c2[,1] 
CI_FD_dem_low <- quantile(FD_dem_low, c(0.025, 0.975))

## First difference: Democracy high -> Outsource max - min
FD_dem_high_hat <- E_Y_c_hat2[4,] - E_Y_c_hat2[3,]  ## max - min
FD_dem_high <- E_Y_c2[,4] - E_Y_c2[,3] 
CI_FD_dem_high <- quantile(FD_dem_high, c(0.025, 0.975))

## First difference of first difference
FD_FD_hat <- FD_dem_high_hat - FD_dem_low_hat
FD_FD <- FD_dem_high - FD_dem_low
CI_FD_FD <- quantile(FD_FD, c(0.025, 0.975))

#-------------------------------------------------------------------------------
## How "big" is the difference compared to variation in the dataset?
#-------------------------------------------------------------------------------
sd_pm25 <- aggregate(data_ova2$populationweightedpm25ugm3,
                     by = list(data_ova2$cname),
                     FUN = sd)

mean_pm25_country_sd <- mean(sd_pm25[,2], na.rm = T)
mean_pm25_sd_between <- sd(data_ova2$populationweightedpm25ugm3)
share_FD_low_var <- FD_dem_low_hat / mean_pm25_country_sd
share_FD_high_var <- abs(FD_dem_high_hat) / mean_pm25_country_sd
share_FD_FD_var <- abs(FD_FD_hat) / mean_pm25_country_sd
share_FD_FD_between <- abs(FD_FD_hat) / mean_pm25_sd_between


#-------------------------------------------------------------------------------
## Plot First differences
#-------------------------------------------------------------------------------
pdf("plots/FDs_dem_high_low.pdf")

plot(y = 1,
     x = FD_dem_low_hat,
     col = viridis(3)[1],
     ylim = c(0,3),
     xlim = c(-2,7),
     xlab = expression("PM"[2.5]*" [micrograms per cubicmeter]"),
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1, x0 = CI_FD_dem_low[1],
         y1 = 1, x1 = CI_FD_dem_low[2],
         col = viridis(3, alpha = 0.4)[1],
         lwd = 12, cex = 1.5, lend = 1)

segments(y0 = 2, x0 = CI_FD_dem_high[1],
         y1 = 2, x1 = CI_FD_dem_high[2],
         col = viridis(3, alpha = 0.4)[1],
         lwd = 12, cex = 1.5, lend = 1)

points(y = 2,
       x = FD_dem_high_hat,
       col = viridis(3)[1],
       xlab = "",
       pch = 19,
       main = NULL, 
       bty = "n",
       ylab = "",
       yaxt = "n",
       cex = 3,
       cex.lab = 1.1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 3,
         lty = "dashed", lwd = 2)

text(x = FD_dem_low_hat,
     y = 0.8,
     labels = c("Non-democratic"),
     cex = 1.1)

text(x = FD_dem_low_hat,
     y = 0.57,
     labels = c("Outsourcing (max - min)"),
     cex = 0.9)

text(x = FD_dem_high_hat-0.35,
     y = 1.8,
     labels = c("Democratic"),
     cex = 1.1)

text(x = FD_dem_high_hat-0.35,
     y = 1.57,
     labels = c("Outsourcing (max - min)"),
     cex = 0.9)

dev.off()

## First difference of first difference
pdf("plots/FD_FD.pdf")

plot(y = 1.5,
     x = FD_FD_hat,
     col = viridis(3)[2],
     ylim = c(0,3),
     xlim = c(-3.5,0.75),
     xlab = expression("PM"[2.5]*" [micrograms per cubicmeter]"),
     pch = 19,
     main = NULL, 
     bty = "n",
     ylab = "",
     yaxt = "n",
     cex = 3,
     cex.lab = 1.1)

segments(y0 = 1.5, x0 = CI_FD_FD[1],
         y1 = 1.5, x1 = CI_FD_FD[2],
         col = viridis(3, alpha = 0.4)[2],
         lwd = 12, cex = 1.5, lend = 1)

segments(x0 = 0, y0 = 0,
         x1 = 0, y1 = 3,
         lty = "dashed", lwd = 2)

text(x = FD_FD_hat,
     y = 1.26,
     labels = c("FD of FD"),
     cex = 1.1)

text(x = FD_FD_hat,
     y = 1.05,
     labels = c("Democracy (high-low)"),
     cex = 0.9)

dev.off()

```



# Robustness

## Replacing DV with PM2.5: ROBUST

```{r replace DV pm25}

#-------------------------------------------------------------------------------
# Model group 2 
#-------------------------------------------------------------------------------
m8_wb_pm25 <- lmer(log_pm25_pop ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                    interaction_demeaned +
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    mean_log_cc_outs + mean_vdem_poly +
                    interaction_mean +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    as.factor(year) + (1 | ccode),
                   data = data_s)

stargazer(m8_wb, m8_wb_pm25, type = "text", omit = c("ccode", "year"))

```

## Replacing DV with carbon footprint: ROBUST

```{r replace DV carbon footprint}

#-------------------------------------------------------------------------------
# Model group 2 
#-------------------------------------------------------------------------------
m8_wb_cf <- lmer(ef_carb ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                    interaction_demeaned +
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    mean_log_cc_outs + mean_vdem_poly +
                    interaction_mean +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    as.factor(year) + (1 | ccode),
                   data = data_s)

stargazer(m8_wb, m8_wb_cf, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Output
#-------------------------------------------------------------------------------
texreg(list(m8_wb, m8_wb_pm25, m8_wb_cf),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg2.doc",
       caption = "Alternative Dependent Variables",
       custom.model.names = c("Model 7", "Model A1-PM2.5", "Model A2-Carbon Footprint"),
       label = "tab:table3",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "interaction_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}")))

```

## Different outsourcing variables: NOT ROBUST (Between for land use & energy)

```{r diff outsourcing}

#-------------------------------------------------------------------------------
# Model group 2 
#-------------------------------------------------------------------------------
m8_wb_bw <- lmer(log_wdi_co2 ~ demeaned_log_bw_outs + demeaned_vdem_poly + 
                     interaction_bw_demeaned +
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + mean_vdem_poly +
                     interaction_bw_mean +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_s)

m8_wb_en <- lmer(log_wdi_co2 ~ demeaned_log_en_outs + demeaned_vdem_poly + 
                     interaction_en_demeaned +
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + mean_vdem_poly +
                     interaction_en_mean +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_s)

m8_wb_lu <- lmer(log_wdi_co2 ~ demeaned_log_lu_outs + demeaned_vdem_poly + 
                     interaction_lu_demeaned +
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + mean_vdem_poly +
                     interaction_lu_mean +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_s)

m8_wb_mf <- lmer(log_wdi_co2 ~ demeaned_log_mf_outs + demeaned_vdem_poly + 
                     interaction_mf_demeaned +
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + mean_vdem_poly +
                     interaction_mf_mean +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_s)

stargazer(m8_wb, m8_wb_bw, m8_wb_en, m8_wb_lu, m8_wb_mf, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Output
#-------------------------------------------------------------------------------
texreg(list(m8_wb, m8_wb_bw, m8_wb_en, m8_wb_lu, m8_wb_mf),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg2.doc",
       caption = "Alternative Outsourcing Variables",
       custom.model.names = c("Model 7", "Model A3-bluewater", "Model A4-energy", "Model A5-landuse", "Model A6-material"),
       label = "tab:table4",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "demeaned_log_bw_outs" = "Pollution Outsourcing (Within)",
                              "demeaned_log_en_outs" = "Pollution Outsourcing (Within)",
                              "demeaned_log_lu_outs" = "Pollution Outsourcing (Within)",
                              "demeaned_log_mf_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "mean_log_bw_outs" = "Pollution Outsourcing (Between)",
                              "mean_log_en_outs" = "Pollution Outsourcing (Between)",
                              "mean_log_lu_outs" = "Pollution Outsourcing (Between)",
                              "mean_log_mf_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "interaction_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_bw_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_en_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_lu_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_mf_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "interaction_bw_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "interaction_en_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "interaction_lu_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "interaction_mf_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}", "\\ding{51}","\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}")))

```

## Alternative operationalization outsourcing: Total sum of pollution outsourced

```{r total sum}

#-------------------------------------------------------------------------------
# Model group 1
#-------------------------------------------------------------------------------
m1_wb_sum <- lmer(log_cc_sum_outs ~ demeaned_vdem_poly + mean_vdem_poly + as.factor(year) +
                   (1 | ccode), 
                  data = data_s[which(!is.na(data_s$log_gdp_pc) &
                                      !is.na(data_s$log_cc_outs)),])

m2_wb_sum <- lmer(log_cc_sum_outs ~ demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
                   mean_log_pop + mean_log_gdp_pc + mean_log_gdp_pc_sq +
                   as.factor(year) + (1 | ccode),
                  data = data_s[which(!is.na(data_s$log_gdp_pc) &
                                      !is.na(data_s$log_cc_outs)),])

m3_wb_sum <- lmer(log_cc_sum_outs ~ demeaned_vdem_poly + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq + 
                   demeaned_log_pop + 
                   mean_vdem_poly + mean_log_gdp_pc + mean_log_gdp_pc_sq + mean_log_pop + as.factor(year) +
                   (1 | ccode), 
                  data = data_s[which(!is.na(data_s$log_gdp_pc) &
                                      !is.na(data_s$log_cc_outs)),])

stargazer(m1_wb_sum, m2_wb_sum, m3_wb_sum, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
## Output
#-------------------------------------------------------------------------------
texreg(list(m1_wb_sum, m2_wb_sum, m3_wb_sum),
       stars = c(0.01, 0.05, 0.1),
       #file = "texreg1.doc",
       caption = "Total Sum of Pollution Outsourced - Analysis 1",
       custom.model.names = c("Model A7", "Model A8", "Model A9"),
       label = "tab:table5",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)", 
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)", 
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}")))


#-------------------------------------------------------------------------------
# Model group 2
#-------------------------------------------------------------------------------
m5_wb_sum <- lmer(log_wdi_co2 ~ demeaned_log_cc_sum_outs + demeaned_vdem_poly + 
                   mean_log_cc_sum_outs + mean_vdem_poly +
                   as.factor(year) + (1 | ccode),
                  data = data_s[which(!is.na(data_s$log_gdp_pc) &
                                      !is.na(data_s$log_cc_outs)),])

m6_wb_sum <- lmer(log_wdi_co2 ~ demeaned_log_cc_sum_outs + demeaned_vdem_poly +
                   interaction_cc_sum_demeaned + 
                   mean_log_cc_sum_outs + mean_vdem_poly +
                   interaction_cc_sum_mean +
                   as.factor(year) + (1 | ccode),
                  data = data_s[which(!is.na(data_s$log_gdp_pc) &
                                      !is.na(data_s$log_cc_outs)),])

m8_wb_sum <- lmer(log_wdi_co2 ~ demeaned_log_cc_sum_outs + demeaned_vdem_poly + 
                   interaction_cc_sum_demeaned +
                   demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                   mean_log_cc_sum_outs + mean_vdem_poly +
                   interaction_cc_sum_mean +
                   mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                   as.factor(year) + (1 | ccode),
                  data = data_s[which(!is.na(data_s$log_gdp_pc) &
                                      !is.na(data_s$log_cc_outs)),])

stargazer(m5_wb_sum, m6_wb_sum, m7_wb, m8_wb_sum, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Output
#-------------------------------------------------------------------------------
texreg(list(m5_wb_sum, m6_wb_sum, m7_wb, m8_wb_sum),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg2.doc",
       caption = "Total Sum of Pollution Outsourced - Analysis 2",
       custom.model.names = c("Model A10", "Model A11", "Model A12", "Model A13"),
       label = "tab:table6",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_sum_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_sum_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_vdem_poly" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "interaction_cc_sum_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_cc_sum_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\xmark", "\\xmark", "\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}")))


```

## Alternative operationalization for democracy: ROBUST

```{r diff  dem}

#-------------------------------------------------------------------------------
# Model group 2 
#-------------------------------------------------------------------------------
m8_wb_polity <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_polity + 
                      interaction_polity_demeaned +
                      demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                      mean_log_cc_outs + mean_polity +
                      interaction_polity_mean +
                      mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                      as.factor(year) + (1 | ccode),
                     data = data_s)

stargazer(m8_wb, m8_wb_polity, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Output
#-------------------------------------------------------------------------------
texreg(list(m8_wb, m8_wb_polity),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg2.doc",
       caption = "Alternative Operationalization for Democracy",
       custom.model.names = c("Model 7-Vdem", "Model A14-Polity"),
       label = "tab:table6",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_vdem_poly" = "Democracy (Within)",
                              "demeaned_polity" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "mean_polity" = "Democracy (Between)",
                              "interaction_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_polity_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "interaction_polity_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}")))
```

## Additional controls: Political globaliz. & env. treaties: NOT ROBUST (BETWEEN)

```{r additional controls}

#-------------------------------------------------------------------------------
# Model group 2 
#-------------------------------------------------------------------------------
m8_wb_ac1 <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                    interaction_demeaned +
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    demeaned_trade + 
                    mean_log_cc_outs + mean_vdem_poly +
                    interaction_mean +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    mean_trade +
                    as.factor(year) + (1 | ccode),
                   data = data_s)

m8_wb_ac2 <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                    interaction_demeaned +
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                   # demeaned_env_treat + (only between because variation only between-countries)
                    mean_log_cc_outs + mean_vdem_poly +
                    interaction_mean +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    mean_env_treat +
                    as.factor(year) + (1 | ccode),
                   data = data_s)

m8_wb_ac3 <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                    interaction_demeaned +
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    demeaned_dr_pg + 
                    mean_log_cc_outs + mean_vdem_poly +
                    interaction_mean +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    mean_dr_pg +
                    as.factor(year) + (1 | ccode),
                   data = data_s)

m8_wb_ac4 <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                    interaction_demeaned +
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    demeaned_gdp + 
                    mean_log_cc_outs + mean_vdem_poly +
                    interaction_mean +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    mean_gdp +
                    as.factor(year) + (1 | ccode),
                   data = data_s)

m8_wb_ac_all <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                      interaction_demeaned +
                      demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                      demeaned_trade + demeaned_dr_pg + demeaned_gdp + 
                      mean_log_cc_outs + mean_vdem_poly +
                      interaction_mean +
                      mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                      mean_trade + mean_env_treat + mean_dr_pg + mean_gdp +
                      as.factor(year) + (1 | ccode),
                    data = data_s)


stargazer(m8_wb, m8_wb_ac1, m8_wb_ac2, m8_wb_ac3, m8_wb_ac4, m8_wb_ac_all, type = "text", omit = c("ccode", "year"))


texreg(list(m8_wb, m8_wb_ac1, m8_wb_ac2, m8_wb_ac3, m8_wb_ac4, m8_wb_ac_all),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg2.doc",
       caption = "Additional Control Variables",
       custom.model.names = c("Model 7", "Model A15", "Model A16", "Model A17", "Model A18", "Model A19"),
       label = "tab:table7",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_polity" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "interaction_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "demeaned_trade" = "Trade Openness (Within)",
                              "mean_trade" = "Trade Openness (Between)",
                              "mean_env_treat" = "Environmental Treaties (Between)",
                              "demeaned_dr_pg" = "Political Globalization (Within)",
                              "mean_dr_pg" = "Political Globalization (Between)",
                              "demeaned_gdp" = "GDP (Within)",
                              "mean_gdp" = "GDP (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}", "\\ding{51}")))


```

## Drop high-income states: ROBUST

```{r drop high-income}

#-------------------------------------------------------------------------------
# Model group 2 
#-------------------------------------------------------------------------------
m8_wb_low_income <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + demeaned_vdem_poly + 
                          interaction_demeaned +
                          demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                          mean_log_cc_outs + mean_vdem_poly +
                          interaction_mean +
                          mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                          as.factor(year) + (1 | ccode),
                         data = data_s[data_s$log_gdp_pc < 10.1,])

stargazer(m8_wb, m8_wb_low_income, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Output
#-------------------------------------------------------------------------------
texreg(list(m8_wb, m8_wb_low_income),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg2.doc",
       caption = "Exclusion of the Richest States",
       custom.model.names = c("Model 7", "Model A20"),
       label = "tab:table9",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_polity" = "Democracy (Within)",
                              "mean_vdem_poly" = "Democracy (Between)",
                              "interaction_demeaned" = "Pollution Outsourcing x Democracy (Within)",
                              "interaction_mean" = "Pollution Outsourcing x Democracy (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}")))
```

## Sample split instead of interaction: ROBUST

```{r sample split}

#-------------------------------------------------------------------------------
# Model group 2 - Split by median of democracy variable (within effects)
#-------------------------------------------------------------------------------
data_dem_low <- data_s[which(data_s$vdem_polyarchy < median(data_s$vdem_polyarchy, na.rm = T)),]
data_dem_high <- data_s[which(data_s$vdem_polyarchy >= median(data_s$vdem_polyarchy, na.rm = T)),]

m8_dem_low <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    mean_log_cc_outs + #mean_vdem_poly +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    as.factor(year) + (1 | ccode),
                   data = data_dem_low)

m8_dem_high <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + #mean_vdem_poly +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_dem_high)

stargazer(m8_dem_low, m8_dem_high, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Model group 2 - Split by median of mean democracy variable (between effects)
#-------------------------------------------------------------------------------
data_dem_low2 <- data_s[which(data_s$mean_vdem_poly < median(data_s$mean_vdem_poly, na.rm = T)),]
data_dem_high2 <- data_s[which(data_s$mean_vdem_poly >= median(data_s$mean_vdem_poly, na.rm = T)),]

m9_dem_low <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                    demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                    mean_log_cc_outs + #mean_vdem_poly +
                    mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                    as.factor(year) + (1 | ccode),
                   data = data_dem_low2)

m9_dem_high <- lmer(log_wdi_co2 ~ demeaned_log_cc_outs + #demeaned_vdem_poly + 
                     demeaned_log_pop + demeaned_log_gdp_pc + demeaned_log_gdp_pc_sq +
                     mean_log_cc_outs + #mean_vdem_poly +
                     mean_log_pop +  mean_log_gdp_pc + mean_log_gdp_pc_sq +
                     as.factor(year) + (1 | ccode),
                    data = data_dem_high2)

stargazer(m9_dem_low, m9_dem_high, type = "text", omit = c("ccode", "year"))


#-------------------------------------------------------------------------------
# Output
#-------------------------------------------------------------------------------
texreg(list(m8_dem_low, m8_dem_high),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg3.doc",
       caption = "Alternative Model Specification - Sample Split (Within)",
       custom.model.names = c("Model A21-Low dem.", "Model A21-High dem."),
       label = "tab:table10",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}")))

texreg(list(m9_dem_low, m9_dem_high),
       stars = c(0.01, 0.05, 0.1),
      # file = "texreg4.doc",
       caption = "Alternative Model Specification - Sample Split (Between)",
       custom.model.names = c("Model A22Low dem.", "Model A22-High dem."),
       label = "tab:table11",
       caption.above = T,
       fontsize = "scriptsize",
       custom.coef.map = list("demeaned_log_cc_outs" = "Pollution Outsourcing (Within)",
                              "mean_log_cc_outs" = "Pollution Outsourcing (Between)",
                              "demeaned_log_pop" = "Population (Within)",
                              "mean_log_pop" = "Population (Between)",
                              "demeaned_log_gdp_pc" = "GDP per capita (Within)",
                              "demeaned_log_gdp_pc_sq" = "GDP per capita squ. (Within)",
                              "mean_log_gdp_pc" = "GDP per capita (Between)",
                              "mean_log_gdp_pc_sq" = "GDP per capita squ. (Between)",
                              "(Intercept)" = "Constant"),
        custom.gof.rows = list("Controls" = c("\\ding{51}", "\\ding{51}"),
                               "Country-FE" = c("\\ding{51}", "\\ding{51}"),
                               "Year-FE" = c("\\ding{51}", "\\ding{51}")))

```







## Random effects model

```{r random}

#-------------------------------------------------------------------------------
# Run model
#-------------------------------------------------------------------------------
model_re <- plm(log_wdi_co2 ~ lag_log_wdi_co2 + export_fdi_index + vdem_polyarchy + 
                   export_fdi_index * vdem_polyarchy, 
                data = panel_data, 
                model = "random",
                effect = "individual")

summary(model_re)
```

